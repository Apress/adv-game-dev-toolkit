{"version":3,"sources":["../src/shortestPath.js"],"names":[],"mappings":"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","file":"shortestPath.js","sourcesContent":["let thingsToLoad = [\n  \"images/timeBombPanic.png\",\n  \"maps/AStar.json\"\n];\n\n//Create a new Hexi instance, and start it.\nlet g = hexi(832, 768, setup, thingsToLoad);\n\n//Set the background color and scale the canvas\n//g.backgroundColor = \"black\";\ng.scaleToWindow();\n\n//Start Hexi\ng.start();\n\n//Game variables\nlet alien, bomb, currentPath;\n\n//The `setup` function to initialize your application\nfunction setup() {\n\n  //Make the world from the Tiled JSON data and the tileset PNG image\n  world = g.makeTiledWorld(\n    \"maps/AStar.json\",\n    \"images/timeBombPanic.png\"\n  );\n\n  //Create the alien sprite \n  alien = world.getObject(\"alien\");\n\n  //Create the bomb sprite\n  //bomb = world.getObject(\"bomb\");\n\n  //Get a reference to the array that stores all the wall data\n  wallMapArray = world.getObject(\"wallLayer\").data;\n\n  //An array to store the sprites that will be used to display \n  //the shortest path \n  currentPathSprites = [];\n\n  //The mouse pointer's `release` function runs the code that\n  //calculates the shortest path and draws that sprites that\n  //represent it\n  g.pointer.release = () => {\n\n    //calculate the shortest path\n    let path = shortestPath(\n      getIndex(alien.x, alien.y, 64, 64, 13), //The start map index\n      getIndex(g.pointer.x, g.pointer.y, 64, 64, 13), //The destination index\n      wallMapArray, //The map array\n      13, //Map width, in tiles\n      [2, 3], //Obstacle gid array\n      \"manhattan\" //Heuristic to use\n    );\n\n    //Use Hexi's `remove` method to remove any possible \n    //sprites in the `currentPathSprites` array\n    g.remove(currentPathSprites);\n\n    //Display the shortest path\n    path.forEach(node => {\n\n      //Figure out the x and y location of each square in the path by\n      //multiplying the node's `column` and `row` by the height, in\n      //pixels, of each square: 64 \n      let x = node.column * 64,\n        y = node.row * 64;\n\n      //Create the square sprite and set it to the x and y location\n      //we calculated above\n      let square = g.rectangle(64, 64, \"black\");\n      square.x = x;\n      square.y = y;\n\n      //Push the sprites into the `currentPath` array,\n      //so that we can easily remove them the next time\n      //the mouse is clicked\n      currentPathSprites.push(square);\n    });\n  };\n}\n\n\n//The `getIndex` helper method\n//converts a sprite's x and y position to an array index number.\n//It returns a single index value that tells you the map array\n//index number that the sprite is in\nfunction getIndex(x, y, tilewidth, tileheight, mapWidthInTiles) {\n  let index = {};\n\n  //Convert pixel coordinates to map index coordinates\n  index.x = Math.floor(x / tilewidth);\n  index.y = Math.floor(y / tileheight);\n\n  //Return the index number\n  return index.x + (index.y * mapWidthInTiles);\n}\n\n//The `shortestPath` function\nfunction shortestPath(\n  startIndex,\n  destinationIndex,\n  mapArray,\n  mapWidthInTiles,\n  obstacleGids = [],\n  heuristic = \"manhattan\"\n) {\n\n  //The `nodes` function creates the array of node objects\n  let nodes = (mapArray, mapWidthInTiles) => {\n    return mapArray.map((cell, index) => {\n\n      //Figure out the row and column of this cell\n      let column = index % mapWidthInTiles;\n      let row = Math.floor(index / mapWidthInTiles);\n\n      //The node object\n      return node = {\n        f: 0,\n        g: 0,\n        h: 0,\n        parent: null,\n        column: column,\n        row: row,\n        index: index\n      };\n    });\n  };\n\n  //Initialize the shortestPath array\n  let shortestPath = [];\n\n  //Initialize the node map\n  let nodeMap = nodes(mapArray, mapWidthInTiles);\n\n  //Initialize the closed and open list arrays\n  let closedList = [];\n  let openList = [];\n\n  //Declare the \"costs\" of travelling in straight or\n  //diagonal lines\n  let straightCost = 10;\n  let diagonalCost = 14;\n\n  //Get the start node\n  let startNode = nodeMap[startIndex];\n\n  //Get the current center node. The first one will \n  //match the path's start position\n  let centerNode = startNode;\n\n  //Push the `centerNode` into the `openList`, because\n  //it's the first node that we're going to check\n  openList.push(centerNode)\n\n  //Get the current destination node. The first one will \n  //match the path's end position\n  let destinationNode = nodeMap[destinationIndex];\n\n  //All the nodes that are surrounding the current map index number\n  let surroundingNodes = (index, mapArray, mapWidthInTiles) => {\n\n    //Find out what all the surrounding nodes are, including those that\n    //might be beyond the borders of the map\n    let allSurroundingNodes = [\n      nodeMap[index - mapWidthInTiles - 1],\n      nodeMap[index - mapWidthInTiles],\n      nodeMap[index - mapWidthInTiles + 1],\n      nodeMap[index - 1],\n      nodeMap[index + 1],\n      nodeMap[index + mapWidthInTiles - 1],\n      nodeMap[index + mapWidthInTiles],\n      nodeMap[index + mapWidthInTiles + 1]\n    ];\n\n    //Optionaly exlude the diagonal nodes, which is often perferable\n    //for 2D maze games\n    let crossSurroundingNodes = [\n      nodeMap[index - mapWidthInTiles],\n      nodeMap[index - 1],\n      nodeMap[index + 1],\n      nodeMap[index + mapWidthInTiles],\n    ];\n\n    //Find the valid sourrounding nodes, which are ones inside \n    //the map border that don't incldue obstacles. Change `allSurroundingNodes`\n    //to `crossSurroundingNodes` to prevent the path from choosing diagonal routes\n    let validSurroundingNodes = allSurroundingNodes.filter(node => {\n\n      //The node will be beyond the top and bottom edges of the\n      //map if it is `undefined`\n      let nodeIsWithinTopAndBottomBounds = node !== undefined;\n\n      //Only return nodes that are within the top and bottom map bounds\n      if (nodeIsWithinTopAndBottomBounds) {\n\n        //Some Boolean values that tell us whether the current map index is on \n        //the left or right border of the map, and whether any of the nodes\n        //surrounding that index extend beyond the left and right borders\n        let indexIsOnLeftBorder = index % mapWidthInTiles === 0\n        let indexIsOnRightBorder = (index + 1) % mapWidthInTiles === 0\n        let nodeIsBeyondLeftBorder = node.column % (mapWidthInTiles - 1) === 0 && node.column !== 0;\n        let nodeIsBeyondRightBorder = node.column % mapWidthInTiles === 0\n\n        //Find out whether of not the node contains an obstacle by looping\n        //through the obstacle gids and and returning `true` if it\n        //finds any at this node's location\n        let nodeContainsAnObstacle = obstacleGids.some(obstacle => {\n          return mapArray[node.index] === obstacle;\n        });\n\n        //If the index is on the left border and any nodes surrounding it are beyond the\n        //left border, don't return that node\n        if (indexIsOnLeftBorder) {\n          //console.log(\"left border\")\n          return !nodeIsBeyondLeftBorder;\n        }\n\n        //If the index is on the right border and any nodes surrounding it are beyond the\n        //right border, don't return that node\n        else if (indexIsOnRightBorder) {\n          //console.log(\"right border\")\n          return !nodeIsBeyondRightBorder;\n        }\n\n        //Return `true` if the node doesn't contain any obstacles\n        else if (nodeContainsAnObstacle) {\n          return false;\n        }\n\n        //The index must be inside the area defined by the left and right borders,\n        //so return the node\n        else {\n          //console.log(\"map interior\")\n          return true;\n        }\n      }\n    });\n\n    //console.log(validSurroundingNodes)\n    //Return the array of `validSurroundingNodes`\n    return validSurroundingNodes;\n  };\n\n  //Diagnostic\n  //console.log(nodeMap);\n  //console.log(centerNode);\n  //console.log(destinationNode);\n  //console.log(wallMapArray);\n  //console.log(surroundingNodes(86, mapArray, mapWidthInTiles));\n\n  //Heuristic methods\n  //1. Manhattan\n  let manhattan = (testNode, destinationNode) => {\n    let h = Math.abs(testNode.row - destinationNode.row) * straightCost + Math.abs(testNode.column - destinationNode.column) * straightCost;\n    return h;\n  };\n\n  //2. Euclidean\n  let euclidean = (testNode, destinationNode) => {\n    let vx = destinationNode.column - testNode.column,\n      vy = destinationNode.row - testNode.row,\n      h = Math.floor(Math.sqrt(vx * vx + vy * vy) * straightCost);\n    return h;\n  };\n\n  //3. Diagonal\n  let diagonal = (testNode, destinationNode) => {\n    let vx = Math.abs(destinationNode.column - testNode.column),\n      vy = Math.abs(destinationNode.row - testNode.row),\n      h = 0;\n\n    if (vx > vy) {\n      h = Math.floor(diagonalCost * vy + straightCost * (vx - vy));\n    } else {\n      h = Math.floor(diagonalCost * vx + straightCost * (vy - vx));\n    }\n    return h;\n  };\n\n  //Loop through all the nodes until the current `centerNode` matches the\n  //`destinationNode`. When they they're the same we know we've reached the\n  //end of the path\n  while (centerNode !== destinationNode) {\n\n    //Find all the nodes surrounding the current `centerNode`\n    let surroundingTestNodes = surroundingNodes(centerNode.index, mapArray, mapWidthInTiles);\n\n    //Loop through all the `surroundingTestNodes` using a classic `for` loop \n    //(A `for` loop gives us a marginal performance boost) \n    for (let i = 0; i < surroundingTestNodes.length; i++) {\n\n      //Get a reference to the current test node\n      let testNode = surroundingTestNodes[i];\n\n      //Find out whether the node is on a straight axis or \n      //a diagonal axis, and assign the appropriate cost\n\n      //A. Declare the cost variable\n      let cost = 0;\n\n      //B. Do they occupy the same row or column?\n      if (centerNode.row === testNode.row || centerNode.column === testNode.column) {\n\n        //If they do, assign a cost of \"10\"\n        cost = straightCost;\n      } else {\n\n        //Otherwise, assign a cost of \"14\"\n        cost = diagonalCost;\n      }\n\n      //C. Calculate the costs (g, h and f) \n      //The node's current cost\n      let g = centerNode.g + cost;\n\n      //The cost of travelling from this node to the \n      //destination node (the heuristic)\n      let h;\n      switch (heuristic) {\n        case \"manhattan\":\n          h = manhattan(testNode, destinationNode);\n          break;\n\n        case \"euclidean\":\n          h = euclidean(testNode, destinationNode);\n          break;\n\n        case \"diagonal\":\n          h = diagonal(testNode, destinationNode);\n          break;\n\n        default:\n          throw new Error(\"Oops! It looks like you misspelled the name of the heuristic\");\n      }\n\n      //The final cost\n      let f = g + h;\n\n      //Find out if the testNode is in either \n      //the openList or closedList array\n      let isOnOpenList = openList.some(node => testNode === node);\n      let isOnClosedList = closedList.some(node => testNode === node);\n\n      //If it's on either of these lists, we can check \n      //whether this route is a lower-cost alternative \n      //to the previous cost calculation. The new G cost \n      //will make the difference to the final F cost \n      if (isOnOpenList || isOnClosedList) {\n        if (testNode.f > f) {\n          testNode.f = f;\n          testNode.g = g;\n          testNode.h = h;\n\n          //Only change the parent if the new cost is lower\n          testNode.parent = centerNode;\n        }\n      }\n\n      //Otherwise, add the testNode to the open list\n      else {\n        testNode.f = f;\n        testNode.g = g;\n        testNode.h = h;\n        testNode.parent = centerNode;\n        openList.push(testNode);\n      }\n\n      //The `for` loop ends here\n    }\n\n    //Push the current centerNode into the closed list\n    closedList.push(centerNode);\n\n    //Quit the loop if there's nothing on the open list.\n    //This means that there is no path to the destination or the \n    //destination is invalid, like a wall tile \n    if (openList.length === 0) {\n\n      return shortestPath;\n    }\n\n    //Sort the open list according to final cost\n    openList = openList.sort((a, b) => a.f - b.f);\n\n    //Set the node with the lowest final cost as the new centerNode\n    centerNode = openList.shift();\n\n    //The `while` loop ends here  \n  }\n\n  //Now that we have all the candidates, let's find the shortest path!\n  if (openList.length !== 0) {\n\n    //Start with the destination node\n    let testNode = destinationNode;\n    shortestPath.push(testNode);\n\n    //Work backwards through the node parents \n    //until the start node is found \n    while (testNode !== startNode) {\n\n      //Step through the parents of each node, \n      //starting with the destination node and ending with the start node\n      testNode = testNode.parent;\n\n      //Add the node to the beginning of the array\n      shortestPath.unshift(testNode);\n\n      //...and then loop again to the next node's parent till you\n      //reach the end of the path\n    }\n  }\n\n  //Return an array of nodes that link together to form\n  //the shortest path\n  return shortestPath;\n}\n\nfunction displayShortestPath(shortestPath) {\n  //console.log(shortestPath)\n  shortestPath.forEach(node => {\n\n    let x = node.column * 64,\n      y = node.row * 64;\n\n    let square = g.rectangle(64, 64, \"black\");\n    square.x = x;\n    square.y = y;\n  });\n}\n\n//Helper functions\n\n//`isCenteredOverCell` returns true or false depending on whether a \n//sprite is exactly aligned to anintersection in the maze corridors\nfunction isCenteredOverCell(sprite) {\n  return Math.floor(sprite.x) % world.tilewidth === 0 && Math.floor(sprite.y) % world.tileheight === 0\n}\n\n//Convert the direction string to an object with `vx` and `vy`\n//velocity properties\nfunction directionToVelocity(direction = \"\", speed = 0) {\n  switch (direction) {\n    case \"up\":\n      return {\n        vy: -speed,\n        vx: 0\n      }\n      break;\n    case \"down\":\n      return {\n        vy: speed,\n        vx: 0\n      };\n      break;\n    case \"left\":\n      return {\n        vx: -speed,\n        vy: 0\n      };\n      break;\n    case \"right\":\n      return {\n        vx: speed,\n        vy: 0\n      };\n      break;\n    default:\n      return {\n        vx: 0,\n        vy: 0\n      };\n  }\n};\n\n//Change the sprite's velocity if it's centered \n//over a tile grid cell \nfunction changeDirection(sprite, direction, speed) {\n  switch (direction) {\n    case \"up\":\n      sprite.vy = -speed;\n      sprite.vx = 0;\n      break;\n    case \"down\":\n      sprite.vy = speed;\n      sprite.vx = 0;\n      break;\n    case \"left\":\n      sprite.vx = -speed;\n      sprite.vy = 0;\n      break;\n    case \"right\":\n      sprite.vx = speed;\n      sprite.vy = 0;\n      break;\n    default:\n      sprite.vx = 0;\n      sprite.vy = 0;\n      break;\n  }\n};\n\nfunction surroundingCrossCells(index, widthInTiles) {\n  return [\n    index - widthInTiles,\n    index - 1,\n    index + 1,\n    index + widthInTiles,\n  ];\n}\n\nfunction surroundingDiagonalCells(index, widthInTiles) {\n  return [\n    index - widthInTiles - 1,\n    index - widthInTiles + 1,\n    index + widthInTiles - 1,\n    index + widthInTiles + 1,\n  ];\n}\n\nfunction validDirections(sprite, mapArray, validGid, world) {\n\n  //Get the sprite's current map index position number\n  let index = g.getIndex(\n    sprite.x,\n    sprite.y,\n    world.tilewidth,\n    world.tileheight,\n    world.widthInTiles\n  );\n\n  //An array containing the index numbers of tile cells\n  //above, below and to the left and right of the sprite\n  let surroundingCrossCells = (index, widthInTiles) => {\n    return [\n      index - widthInTiles,\n      index - 1,\n      index + 1,\n      index + widthInTiles,\n    ];\n  };\n\n  //Get the index position numbers of the 4 cells to the top, right, left\n  //and bottom of the sprite\n  let surroundingIndexNumbers = surroundingCrossCells(index, world.widthInTiles);\n\n  //Find all the tile gid numbers that match the surrounding index numbers\n  let surroundingTileGids = surroundingIndexNumbers.map(index => mapArray[index]);\n\n  //`directionList` is an array of 4 string values that can be either\n  //\"up\", \"left\", \"right\", \"down\" or \"none\", depending on \n  //whether there is a cell with a valid gid that matches that direction.\n  let directionList = surroundingTileGids.map((gid, i) => {\n\n    //The possible directions\n    let possibleDirections = [\"up\", \"left\", \"right\", \"down\"];\n\n    //If the direction is valid, choose the matching string \n    //identifier for that direction. Otherwise, return \"none\"\n    if (gid === validGid) {\n      return possibleDirections[i];\n    } else {\n      return \"none\";\n    }\n  });\n\n  //We don't need \"none\" in the list of directions \n  //(it's just a placeholder), so let's filter it out\n  let filteredDirectionList = directionList.filter(direction => direction != \"none\");\n\n  //Return the filtered list of valid directions\n  return filteredDirectionList;\n}\n\nfunction canChangeDirection(validDirections = []) {\n\n  //Is the sprite in a dead-end (cul de sac.) This will be true if there's only\n  //one element in the `validDirections` array\n  let inCulDeSac = validDirections.length === 1;\n\n  //Is the sprite trapped? This will be true if there are no elements in\n  //the `validDirections` array\n  let trapped = validDirections.length === 0;\n\n  //Is the sprite in a passage? This will be `true` if the the sprite\n  //is at a location that contain the values \n  //“left” or “right” and “up” or “down” \n  let up = validDirections.find(x => x === \"up\"),\n    down = validDirections.find(x => x === \"down\"),\n    left = validDirections.find(x => x === \"left\"),\n    right = validDirections.find(x => x === \"right\"),\n    atIntersection = (up || down) && (left || right);\n\n  //Return `true` if the sprite can change direction or\n  //`false` if it can't\n  return trapped || atIntersection || inCulDeSac;\n}\n\nfunction randomDirection(sprite, validDirections = []) {\n\n  //The `randomInt` helper function returns a random integer between a minimum\n  //and maximum value\n  let randomInt = (min, max) => {\n    return Math.floor(Math.random() * (max - min + 1)) + min;\n  };\n\n  //Is the sprite trapped? \n  let trapped = validDirections.length === 0;\n\n  //If the sprite isn't trapped, randomly choose one of the valid\n  //directions. Otherwise, return the string \"trapped\"\n  if (!trapped) {\n    return validDirections[randomInt(0, validDirections.length - 1)];\n  } else {\n    return \"trapped\"\n  }\n}\n/*\nfunction randomDirection(sprite, currentDirection = \"none\", validDirections = []) {\n\n  //Some values that help find out what the sprite's situation in the maze is\n  //Is the sprite in an up/down passage?\n  //let inUpOrDownPassage = validDirections.indexOf(\"up\") !== -1 || validDirections.indexOf(\"down\") !== -1;\n  let inUpOrDownPassage = validDirections.indexOf(\"up\") !== -1 || validDirections.indexOf(\"down\") !== -1;\n\n  //Is the sprite in a left/right passage?\n  let inLeftOrRightPassage = validDirections.indexOf(\"left\") !== -1 || validDirections.indexOf(\"right\") !== -1;\n\n  //Is the sprite in a dead-end (cul de sac.) This will be true if there's only\n  //one element in the `validDirections` array\n  let inCulDeSac = validDirections.length === 1;\n\n  //Is the sprite trapped? This will be true if there are no elements in\n  //the `validDirections` array\n  let trapped = validDirections.length === 0;\n\n  //The `randomInt` helper function returns a random integer between a minimum\n  //and maximum value\n  let randomInt = (min, max) => {\n    return Math.floor(Math.random() * (max - min + 1)) + min;\n  };\n\n  //Randomly select one of the valid directions\n  let randomDirection = () => {\n    if (!trapped) {\n      return validDirections[randomInt(0, validDirections.length - 1)];\n    } else {\n      return \"none\"\n    }\n  };\n\n  //If the sprite isn't trapped and it's in a passage intersection or\n  //cul-de-sac, assign the newRandomDirecton to the sprite's\n  //`direction` property. Otherwise, keep the sprite's directon the \n  //same as it was before\n  if (!trapped) {\n    if (inLeftOrRightPassage && inUpOrDownPassage || inCulDeSac) {\n      return randomDirection();\n    } else {\n      return currentDirection;\n    }\n  } else {\n    return currentDirection;\n  }\n}\n*/"]}