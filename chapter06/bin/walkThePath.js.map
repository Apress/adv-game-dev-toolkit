{"version":3,"sources":["../src/walkThePath.js"],"names":[],"mappings":"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","file":"walkThePath.js","sourcesContent":["let thingsToLoad = [\n  \"images/timeBombPanic.png\",\n  \"maps/walkThePath.json\"\n];\n\n//Create a new Hexi instance, and start it.\nlet g = hexi(832, 768, setup, thingsToLoad);\n\n//Set the background color and scale the canvas\n//g.backgroundColor = \"black\";\ng.scaleToWindow();\n\n//Start Hexi\ng.start();\n\n//Game variables\nlet alien, wayPoints2DArray, calculateNewPath,\n  destinationX, destinationY;\n\n//The `setup` function to initialize your application\nfunction setup() {\n\n  //Make the world from the Tiled JSON data and the tileset PNG image\n  world = g.makeTiledWorld(\n    \"maps/walkThePath.json\",\n    \"images/timeBombPanic.png\"\n  );\n\n  //Create the alien sprite \n  alien = world.getObject(\"alien\");\n\n  //Create the bomb sprite\n  //bomb = world.getObject(\"bomb\");\n\n  //Get a reference to the array that stores all the wall data\n  wallMapArray = world.getObject(\"wallLayer\").data;\n\n  //An array that will be used to store sub-arrays of \n  //x/y position value pairs that we're going to use\n  //to change the velocity of the alien sprite\n  wayPoints2DArray = [];\n\n  //A Boolean that will be set to true when the pointer\n  //is clicked, and set to false when the new path\n  //is calculated\n  calculateNewPath = false;\n\n\n  //The mouse pointer's `release` function runs the code that\n  //calculates the shortest path and draws that sprites that\n  //represent it\n  g.pointer.release = () => {\n\n    //Set the new path's desination to the pointer's\n    //current x and y position\n    destinationX = g.pointer.x;\n    destinationY = g.pointer.y;\n\n    //Set `calculateNewPath` to true\n    calculateNewPath = true;\n  };\n\n\n  //Change the game state to `play` to start the game loop\n  g.state = play;\n}\n\nfunction play() {\n\n  //Find out if the alien is centered over a tile cell \n  if (isCenteredOverCell(alien)) {\n\n    //If `calculateNewPath` has been set to `true` by the pointer,\n    //Find the new shortest path between the alien and the pointer's\n    //x and y position (`destinationX` and `destinationY`)\n    if (calculateNewPath) {\n\n      //calculate the shortest path\n      let path = shortestPath(\n        getIndex(alien.centerX, alien.centerY, 64, 64, 13), //The start map index\n        getIndex(destinationX, destinationY, 64, 64, 13), //The destination index\n        wallMapArray, //The map array\n        13, //Map width, in tiles\n        [2, 3], //Obstacle gid array\n        \"manhattan\" //Heuristic to use\n      );\n\n      //Remove the first node of the `path` array. That's because we\n      //don't need it: the alien sprite's current location and the\n      //first node in the `path` array share the same location.\n      //In the code ahead we're going to tell the alien sprite to move\n      //from its current location, to first new node in the path.\n      path.shift();\n\n      //If the path isn't empty, fill the `wayPoints2DArray` with\n      //sub arrays of x/y position value pairs. \n      if (path.length !== 0) {\n\n        //Get a 2D array of x/y points\n        wayPoints2DArray = path.map(node => {\n\n          //Figure out the x and y location of each square in the path by\n          //multiplying the node's `column` and `row` by the height, in\n          //pixels, of each cell: 64 \n          let x = node.column * 64,\n            y = node.row * 64;\n\n          //Return a sub-array containing the x and y position of each node\n          return [x, y];\n        });\n      }\n\n      //Set `calculateNewPath` to `false` so that this block of code.\n      //won't run again inside the game loop. (It can be set to `true`\n      //again by clicking the pointer.) \n      calculateNewPath = false;\n    }\n\n    //Set the alien's new velocity based on \n    //the alien's relative x/y position to the current, next, way point. \n    //Because we are always going to \n    //remove a way point element after we set this new \n    //velocity, the first element in the `wayPoints2DArray`\n    //will always refer to the next way point that the \n    //alien sprite has to move to  \n    if (wayPoints2DArray.length !== 0) {\n\n      //Left\n      if (wayPoints2DArray[0][0] < alien.x) {\n        alien.vx = -4;\n        alien.vy = 0;\n\n        //Right\n      } else if (wayPoints2DArray[0][0] > alien.x) {\n        alien.vx = 4;\n        alien.vy = 0;\n\n        //Up\n      } else if (wayPoints2DArray[0][1] < alien.y) {\n        alien.vx = 0;\n        alien.vy = -4;\n\n        //Down\n      } else if (wayPoints2DArray[0][1] > alien.y) {\n        alien.vx = 0;\n        alien.vy = 4;\n      }\n\n      //Remove the current way point, so that next time around\n      //the first element in the `wayPoints2DArray` will correctly refer\n      //to the next way point that that alien sprite has\n      //to move to\n      wayPoints2DArray.shift();\n\n      //If there are no way points remaining, \n      //set the alien's velocity to 0\n    } else {\n      alien.vx = 0;\n      alien.vy = 0;\n    }\n  }\n\n  //Move the alien based on the new velocity\n  alien.x += alien.vx;\n  alien.y += alien.vy;\n}\n\n//Helper functions\n//`isCenteredOverCell` returns true or false depending on whether a \n//sprite is exactly aligned to an intersection in the maze corridors\nfunction isCenteredOverCell(sprite) {\n  return Math.floor(sprite.x) % world.tilewidth === 0 && Math.floor(sprite.y) % world.tileheight === 0\n}\n\n\n//The `getIndex` helper method\n//converts a sprite's x and y position to an array index number.\n//It returns a single index value that tells you the map array\n//index number that the sprite is in\nfunction getIndex(x, y, tilewidth, tileheight, mapWidthInTiles) {\n  let index = {};\n\n  //Convert pixel coordinates to map index coordinates\n  index.x = Math.floor(x / tilewidth);\n  index.y = Math.floor(y / tileheight);\n\n  //Return the index number\n  return index.x + (index.y * mapWidthInTiles);\n}\n\n//The `shortestPath` function\nfunction shortestPath(\n  startIndex,\n  destinationIndex,\n  mapArray,\n  mapWidthInTiles,\n  obstacleGids = [],\n  heuristic = \"manhattan\"\n) {\n\n  //The `nodes` function creates the array of node objects\n  let nodes = (mapArray, mapWidthInTiles) => {\n    return mapArray.map((cell, index) => {\n\n      //Figure out the row and column of this cell\n      let column = index % mapWidthInTiles;\n      let row = Math.floor(index / mapWidthInTiles);\n\n      //The node object\n      return node = {\n        f: 0,\n        g: 0,\n        h: 0,\n        parent: null,\n        column: column,\n        row: row,\n        index: index\n      };\n    });\n  };\n\n  //Initialize the shortestPath array\n  let shortestPath = [];\n\n  //Initialize the node map\n  let nodeMap = nodes(mapArray, mapWidthInTiles);\n\n  //Initialize the closed and open list arrays\n  let closedList = [];\n  let openList = [];\n\n  //Declare the \"costs\" of travelling in straight or\n  //diagonal lines\n  let straightCost = 10;\n  let diagonalCost = 14;\n\n  //Get the start node\n  let startNode = nodeMap[startIndex];\n\n  //Get the current center node. The first one will \n  //match the path's start position\n  let centerNode = startNode;\n\n  //Push the `centerNode` into the `openList`, because\n  //it's the first node that we're going to check\n  openList.push(centerNode)\n\n  //Get the current destination node. The first one will \n  //match the path's end position\n  let destinationNode = nodeMap[destinationIndex];\n\n  //All the nodes that are surrounding the current map index number\n  let surroundingNodes = (index, mapArray, mapWidthInTiles) => {\n\n    //Find out what all the surrounding nodes are, including those that\n    //might be beyond the borders of the map\n    let allSurroundingNodes = [\n      nodeMap[index - mapWidthInTiles - 1],\n      nodeMap[index - mapWidthInTiles],\n      nodeMap[index - mapWidthInTiles + 1],\n      nodeMap[index - 1],\n      nodeMap[index + 1],\n      nodeMap[index + mapWidthInTiles - 1],\n      nodeMap[index + mapWidthInTiles],\n      nodeMap[index + mapWidthInTiles + 1]\n    ];\n\n    //Optionaly exlude the diagonal nodes, which is often perferable\n    //for 2D maze games\n    let crossSurroundingNodes = [\n      nodeMap[index - mapWidthInTiles],\n      nodeMap[index - 1],\n      nodeMap[index + 1],\n      nodeMap[index + mapWidthInTiles],\n    ];\n\n    //Find the valid sourrounding nodes, which are ones inside \n    //the map border that don't incldue obstacles. Change `allSurroundingNodes`\n    //to `crossSurroundingNodes` to prevent the path from choosing diagonal routes\n    let validSurroundingNodes = crossSurroundingNodes.filter(node => {\n\n      //The node will be beyond the top and bottom edges of the\n      //map if it is `undefined`\n      let nodeIsWithinTopAndBottomBounds = node !== undefined;\n\n      //Only return nodes that are within the top and bottom map bounds\n      if (nodeIsWithinTopAndBottomBounds) {\n\n        //Some Boolean values that tell us whether the current map index is on \n        //the left or right border of the map, and whether any of the nodes\n        //surrounding that index extend beyond the left and right borders\n        let indexIsOnLeftBorder = index % mapWidthInTiles === 0\n        let indexIsOnRightBorder = (index + 1) % mapWidthInTiles === 0\n        let nodeIsBeyondLeftBorder = node.column % (mapWidthInTiles - 1) === 0 && node.column !== 0;\n        let nodeIsBeyondRightBorder = node.column % mapWidthInTiles === 0\n\n        //Find out whether of not the node contains an obstacle by looping\n        //through the obstacle gids and and returning `true` if it\n        //finds any at this node's location\n        let nodeContainsAnObstacle = obstacleGids.some(obstacle => {\n          return mapArray[node.index] === obstacle;\n        });\n\n        //If the index is on the left border and any nodes surrounding it are beyond the\n        //left border, don't return that node\n        if (indexIsOnLeftBorder) {\n          //console.log(\"left border\")\n          return !nodeIsBeyondLeftBorder;\n        }\n\n        //If the index is on the right border and any nodes surrounding it are beyond the\n        //right border, don't return that node\n        else if (indexIsOnRightBorder) {\n          //console.log(\"right border\")\n          return !nodeIsBeyondRightBorder;\n        }\n\n        //Return `true` if the node doesn't contain any obstacles\n        else if (nodeContainsAnObstacle) {\n          return false;\n        }\n\n        //The index must be inside the area defined by the left and right borders,\n        //so return the node\n        else {\n          //console.log(\"map interior\")\n          return true;\n        }\n      }\n    });\n\n    //console.log(validSurroundingNodes)\n    //Return the array of `validSurroundingNodes`\n    return validSurroundingNodes;\n  };\n\n  //Diagnostic\n  //console.log(nodeMap);\n  //console.log(centerNode);\n  //console.log(destinationNode);\n  //console.log(wallMapArray);\n  //console.log(surroundingNodes(86, mapArray, mapWidthInTiles));\n\n  //Heuristic methods\n  //1. Manhattan\n  let manhattan = (testNode, destinationNode) => {\n    let h = Math.abs(testNode.row - destinationNode.row) * straightCost + Math.abs(testNode.column - destinationNode.column) * straightCost;\n    return h;\n  };\n\n  //2. Euclidean\n  let euclidean = (testNode, destinationNode) => {\n    let vx = destinationNode.column - testNode.column,\n      vy = destinationNode.row - testNode.row,\n      h = Math.floor(Math.sqrt(vx * vx + vy * vy) * straightCost);\n    return h;\n  };\n\n  //3. Diagonal\n  let diagonal = (testNode, destinationNode) => {\n    let vx = Math.abs(destinationNode.column - testNode.column),\n      vy = Math.abs(destinationNode.row - testNode.row),\n      h = 0;\n\n    if (vx > vy) {\n      h = Math.floor(diagonalCost * vy + straightCost * (vx - vy));\n    } else {\n      h = Math.floor(diagonalCost * vx + straightCost * (vy - vx));\n    }\n    return h;\n  };\n\n  //Loop through all the nodes until the current `centerNode` matches the\n  //`destinationNode`. When they they're the same we know we've reached the\n  //end of the path\n  while (centerNode !== destinationNode) {\n\n    //Find all the nodes surrounding the current `centerNode`\n    let surroundingTestNodes = surroundingNodes(centerNode.index, mapArray, mapWidthInTiles);\n\n    //Loop through all the `surroundingTestNodes` using a classic `for` loop \n    //(A `for` loop gives us a marginal performance boost) \n    for (let i = 0; i < surroundingTestNodes.length; i++) {\n\n      //Get a reference to the current test node\n      let testNode = surroundingTestNodes[i];\n\n      //Find out whether the node is on a straight axis or \n      //a diagonal axis, and assign the appropriate cost\n\n      //A. Declare the cost variable\n      let cost = 0;\n\n      //B. Do they occupy the same row or column?\n      if (centerNode.row === testNode.row || centerNode.column === testNode.column) {\n\n        //If they do, assign a cost of \"10\"\n        cost = straightCost;\n      } else {\n\n        //Otherwise, assign a cost of \"14\"\n        cost = diagonalCost;\n      }\n\n      //C. Calculate the costs (g, h and f) \n      //The node's current cost\n      let g = centerNode.g + cost;\n\n      //The cost of travelling from this node to the \n      //destination node (the heuristic)\n      let h;\n      switch (heuristic) {\n        case \"manhattan\":\n          h = manhattan(testNode, destinationNode);\n          break;\n\n        case \"euclidean\":\n          h = euclidean(testNode, destinationNode);\n          break;\n\n        case \"diagonal\":\n          h = diagonal(testNode, destinationNode);\n          break;\n\n        default:\n          throw new Error(\"Oops! It looks like you misspelled the name of the heuristic\");\n      }\n\n      //The final cost\n      let f = g + h;\n\n      //Find out if the testNode is in either \n      //the openList or closedList array\n      let isOnOpenList = openList.some(node => testNode === node);\n      let isOnClosedList = closedList.some(node => testNode === node);\n\n      //If it's on either of these lists, we can check \n      //whether this route is a lower-cost alternative \n      //to the previous cost calculation. The new G cost \n      //will make the difference to the final F cost \n      if (isOnOpenList || isOnClosedList) {\n        if (testNode.f > f) {\n          testNode.f = f;\n          testNode.g = g;\n          testNode.h = h;\n\n          //Only change the parent if the new cost is lower\n          testNode.parent = centerNode;\n        }\n      }\n\n      //Otherwise, add the testNode to the open list\n      else {\n        testNode.f = f;\n        testNode.g = g;\n        testNode.h = h;\n        testNode.parent = centerNode;\n        openList.push(testNode);\n      }\n\n      //The `for` loop ends here\n    }\n\n    //Push the current centerNode into the closed list\n    closedList.push(centerNode);\n\n    //Quit the loop if there's nothing on the open list.\n    //This means that there is no path to the destination or the \n    //destination is invalid, like a wall tile \n    if (openList.length === 0) {\n\n      return shortestPath;\n    }\n\n    //Sort the open list according to final cost\n    openList = openList.sort((a, b) => a.f - b.f);\n\n    //Set the node with the lowest final cost as the new centerNode\n    centerNode = openList.shift();\n\n    //The `while` loop ends here  \n  }\n\n  //Now that we have all the candidates, let's find the shortest path!\n  if (openList.length !== 0) {\n\n    //Start with the destination node\n    let testNode = destinationNode;\n    shortestPath.push(testNode);\n\n    //Work backwards through the node parents \n    //until the start node is found \n    while (testNode !== startNode) {\n\n      //Step through the parents of each node, \n      //starting with the destination node and ending with the start node\n      testNode = testNode.parent;\n\n      //Add the node to the beginning of the array\n      shortestPath.unshift(testNode);\n\n      //...and then loop again to the next node's parent till you\n      //reach the end of the path\n    }\n  }\n\n  //Return an array of nodes that link together to form\n  //the shortest path\n  return shortestPath;\n}"]}