{"version":3,"sources":["../src/cubes.js"],"names":[],"mappings":"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","file":"cubes.js","sourcesContent":["//The images we want to load\nlet thingsToLoad = [\n  \"images/cubes.png\",\n  \"images/cubes.json\"\n];\n\n//Create a new Hexi instance, and start it.\nlet g = hexi(512, 512, setup, thingsToLoad);\n\n//Scale the canvas to the maximum browser dimensions\ng.scaleToWindow();\n\n//Declare variables used in more than one function\nlet world, leftArrow, upArrow,\n  rightArrow, downArrow, message, wallLayer,\n  player, groundLayer, wallMapArray;\n\n//Start Hexi\ng.start();\n\nfunction setup() {\n\n  //Make the world from the Tiled JSON data\n  world = makeIsoTiledWorld(\n    \"images/cubes.json\",\n    \"images/cubes.png\"\n  );\n\n  //Add the world to the `stage`\n  g.stage.addChild(world);\n\n  //Position the world inside the canvas\n  let canvasOffset = (g.canvas.width / 2) - world.tilewidth / 2;\n  world.x += canvasOffset;\n  world.y = 0;\n\n  //Get the objects we need from the world\n  player = world.getObject(\"player\");\n  wallLayer = world.getObject(\"wallLayer\");\n  console.log(wallLayer.data)\n\n  //Add the player to the wall layer and set it at\n  //the same depth level as the walls\n  wallLayer.addChild(player);\n  player.z = 0;\n  wallLayer.children.sort(byDepth);\n\n  //Initialize the player's velocity to zero\n  player.vx = 0;\n  player.vy = 0;\n\n  //Make a text object\n  message = g.text(\"\", \"16px Futura\", \"black\");\n  message.setPosition(5, 0);\n\n  //Add isometric properties to the pointer\n  makeIsoPointer(g.pointer, world);\n\n  //Create the keyboard objects\n  leftArrow = g.keyboard(37);\n  upArrow = g.keyboard(38);\n  rightArrow = g.keyboard(39);\n  downArrow = g.keyboard(40);\n\n  //Assign the key `press` actions\n  player.direction = \"none\";\n  leftArrow.press = () => player.direction = \"left\";\n  upArrow.press = () => player.direction = \"up\";\n  rightArrow.press = () => player.direction = \"right\";\n  downArrow.press = () => player.direction = \"down\";\n  leftArrow.release = () => player.direction = \"none\";\n  upArrow.release = () => player.direction = \"none\";\n  rightArrow.release = () => player.direction = \"none\";\n  downArrow.release = () => player.direction = \"none\";\n\n  //Set the game state to `play`\n  g.state = play;\n}\n\nfunction play() {\n\n  //Change the player character's velocity if it's centered over a grid cell\n  if (Math.floor(player.cartX) % world.cartTilewidth === 0 && Math.floor(player.cartY) % world.cartTileheight === 0) {\n    switch (player.direction) {\n      case \"up\":\n        player.vy = -2;\n        player.vx = 0;\n        break;\n      case \"down\":\n        player.vy = 2;\n        player.vx = 0;\n        break;\n      case \"left\":\n        player.vx = -2;\n        player.vy = 0;\n        break;\n      case \"right\":\n        player.vx = 2;\n        player.vy = 0;\n        break;\n      case \"none\":\n        player.vx = 0;\n        player.vy = 0;\n        break;\n    }\n  }\n\n  //Update the player's Cartesian position \n  //based on its velocity\n  player.cartY += player.vy;\n  player.cartX += player.vx;\n\n  //Wall collision\n  //Get a reference to the wall map array\n  wallMapArray = wallLayer.data;\n\n  //Use `hitTestIsoTile` to check for a collision\n  let playerVsGround = hitTestIsoTile(player, wallMapArray, 0, world, \"every\");\n\n  //If there's a collision, prevent the player from moving.\n  //Subtract its velocity from its position and then set its velocity to zero\n  if (!playerVsGround.hit) {\n    player.cartX -= player.vx;\n    player.cartY -= player.vy;\n    player.vx = 0;\n    player.vy = 0;\n  }\n\n  //Add world boundaries\n  let top = 0,\n    bottom = (world.heightInTiles * world.cartTileheight),\n    left = 0,\n    right = (world.widthInTiles * world.cartTilewidth);\n\n  //Prevent the player from crossing any of the world boundaries\n  //Top\n  if (player.cartY < 0) {\n    player.cartY = top;\n  }\n\n  //Bottom\n  if (player.cartY + player.cartHeight > bottom) {\n    player.cartY = bottom - player.cartHeight;\n  }\n\n  //Left\n  if (player.cartX < left) {\n    player.cartX = left;\n  }\n\n  //Right\n  if (player.cartX + player.cartWidth > right) {\n    player.cartX = right - player.cartWidth;\n  }\n\n  //Position the sprite's screen `x` and `y` position\n  //using its isometric coordinates\n  player.x = player.isoX;\n  player.y = player.isoY;\n\n  //Get the player's index position in the map array\n  player.index = g.getIndex(\n    player.cartX, player.cartY,\n    world.cartTilewidth, world.cartTileheight, world.widthInTiles\n  );\n\n  //Depth sort the sprites if the player is moving\n  if (player.vx !== 0 || player.vy !== 0) {\n    wallLayer.children.sort(byDepth);\n  }\n\n  //Display the player's x, y and index values\n  message.content = `index: ${player.index}`;\n}\n\n//Helper functions\n\nfunction makeIsoTiledWorld(jsonTiledMap, tileset) {\n\n  //Create a group called `world` to contain all the layers, sprites\n  //and objects from the `tiledMap`. The `world` object is going to be\n  //returned to the main game program\n  let tiledMap = PIXI.loader.resources[jsonTiledMap].data;\n\n  //A. You need to add three custom properties to your Tiled Editor\n  //map: `cartTilewidth`,`cartTileheight` and `tileDepth`. They define the Cartesian\n  //dimesions of the tiles (32x32x64).\n  //Check to make sure that these custom properties exist  \n  if (!tiledMap.properties.cartTilewidth && !tiledMap.properties.cartTileheight && !tiledMao.properties.tileDepth) {\n    throw new Error(\n      \"Set custom cartTilewidth, cartTileheight and tileDepth map properties in Tiled Editor\"\n    );\n  }\n\n  //Create the `world` container\n  let world = new PIXI.Container();\n\n  //B. Set the `tileHeight` to the `tiledMap`'s `tileDepth` property\n  //so that it matches the pixel height of the sprite tile image\n  world.tileheight = parseInt(tiledMap.properties.tileDepth);\n  world.tilewidth = tiledMap.tilewidth;\n\n\n  //C. Define the Cartesian dimesions of each tile\n  world.cartTileheight = parseInt(tiledMap.properties.cartTileheight);\n  world.cartTilewidth = parseInt(tiledMap.properties.cartTilewidth);\n\n  //D. Calculate the `width` and `height` of the world, in pixels\n  //using the `world.cartTileHeight` and `world.cartTilewidth`\n  //values\n  world.worldWidth = tiledMap.width * world.cartTilewidth;\n  world.worldHeight = tiledMap.height * world.cartTileheight;\n\n  //Get a reference to the world's height and width in\n  //tiles, in case you need to know this later (you will!)\n  world.widthInTiles = tiledMap.width;\n  world.heightInTiles = tiledMap.height;\n\n  //Create an `objects` array to store references to any\n  //named objects in the map. Named objects all have\n  //a `name` property that was assigned in Tiled Editor\n  world.objects = [];\n\n  //The optional spacing (padding) around each tile\n  //This is to account for spacing around tiles\n  //that's commonly used with texture atlas tilesets. Set the\n  //`spacing` property when you create a new map in Tiled Editor\n  let spacing = tiledMap.tilesets[0].spacing;\n\n  //Figure out how many columns there are on the tileset.\n  //This is the width of the image, divided by the width\n  //of each tile, plus any optional spacing thats around each tile\n  let numberOfTilesetColumns =\n    Math.floor(\n      tiledMap.tilesets[0].imagewidth / (tiledMap.tilewidth + spacing)\n    );\n\n  //E. A `z` property to help track which depth level the sprites are on\n  let z = 0;\n\n  //Loop through all the map layers\n  tiledMap.layers.forEach(tiledLayer => {\n\n    //Make a group for this layer and copy\n    //all of the layer properties onto it.\n    let layerGroup = new PIXI.Container();\n\n    Object.keys(tiledLayer).forEach(key => {\n      //Add all the layer's properties to the group, except the\n      //width and height (because the group will work those our for\n      //itself based on its content).\n      if (key !== \"width\" && key !== \"height\") {\n        layerGroup[key] = tiledLayer[key];\n      }\n    });\n\n    //Translate `opacity` to `alpha`\n    layerGroup.alpha = tiledLayer.opacity;\n\n    //Add the group to the `world`\n    world.addChild(layerGroup);\n\n    //Push the group into the world's `objects` array\n    //So you can access it later\n    world.objects.push(layerGroup);\n\n    //Is this current layer a `tilelayer`?\n    if (tiledLayer.type === \"tilelayer\") {\n\n      //Loop through the `data` array of this layer\n      tiledLayer.data.forEach((gid, index) => {\n        let tileSprite, texture, mapX, mapY, tilesetX, tilesetY,\n          mapColumn, mapRow, tilesetColumn, tilesetRow;\n\n        //If the grid id number (`gid`) isn't zero, create a sprite\n        if (gid !== 0) {\n\n          //Figure out the map column and row number that we're on, and then\n          //calculate the grid cell's x and y pixel position.\n          mapColumn = index % world.widthInTiles;\n          mapRow = Math.floor(index / world.widthInTiles);\n\n          //mapColumn = index % tiledMap.width;\n          //mapRow = Math.floor(index / tiledMap.width);\n\n          //F. Use the Cartesian values to find the \n          //`mapX` and `mapY` values\n          mapX = mapColumn * world.cartTilewidth;\n          mapY = mapRow * world.cartTileheight;\n\n          //Figure out the column and row number that the tileset\n          //image is on, and then use those values to calculate\n          //the x and y pixel position of the image on the tileset\n          tilesetColumn = ((gid - 1) % numberOfTilesetColumns);\n          tilesetRow = Math.floor((gid - 1) / numberOfTilesetColumns);\n          tilesetX = tilesetColumn * world.tilewidth;\n          tilesetY = tilesetRow * world.tileheight;\n\n          //Compensate for any optional spacing (padding) around the tiles if\n          //there is any. This bit of code accumlates the spacing offsets from the\n          //left side of the tileset and adds them to the current tile's position\n          if (spacing > 0) {\n            tilesetX += spacing + (spacing * ((gid - 1) % numberOfTilesetColumns));\n            tilesetY += spacing + (spacing * Math.floor((gid - 1) / numberOfTilesetColumns));\n          }\n\n          //Use the above values to create the sprite's image from\n          //the tileset image\n          texture = g.frame(\n            tileset, tilesetX, tilesetY,\n            world.tilewidth, world.tileheight\n          );\n\n          //I've dedcided that any tiles that have a `name` property are important\n          //and should be accessible in the `world.objects` array.\n\n          let tileproperties = tiledMap.tilesets[0].tileproperties,\n            key = String(gid - 1);\n\n          //If the JSON `tileproperties` object has a sub-object that\n          //matches the current tile, and that sub-object has a `name` property,\n          //then create a sprite and assign the tile properties onto\n          //the sprite\n          if (tileproperties[key] && tileproperties[key].name) {\n\n            //Make a sprite\n            tileSprite = new PIXI.Sprite(texture);\n\n            //Copy all of the tile's properties onto the sprite\n            //(This includes the `name` property)\n            Object.keys(tileproperties[key]).forEach(property => {\n\n              //console.log(tileproperties[key][property])\n              tileSprite[property] = tileproperties[key][property];\n            });\n\n            //Push the sprite into the world's `objects` array\n            //so that you can access it by `name` later\n            world.objects.push(tileSprite);\n          }\n\n          //If the tile doesn't have a `name` property, just use it to\n          //create an ordinary sprite (it will only need one texture)\n          else {\n            tileSprite = new PIXI.Sprite(texture);\n          }\n\n          //G. Add isometric properties to the sprite\n          addIsoProperties(\n            tileSprite, mapX, mapY,\n            world.cartTilewidth, world.cartTileheight\n          );\n\n          //H. Use the isometric position to add the sprite to the world\n          tileSprite.x = tileSprite.isoX;\n          tileSprite.y = tileSprite.isoY;\n          tileSprite.z = z;\n\n          //Make a record of the sprite's index number in the array\n          //(We'll use this for collision detection later)\n          tileSprite.index = index;\n\n          //Make a record of the sprite's `gid` on the tileset.\n          //This will also be useful for collision detection later\n          tileSprite.gid = gid;\n\n          //Add the sprite to the current layer group\n          layerGroup.addChild(tileSprite);\n        }\n      });\n    }\n\n    //Is this layer an `objectgroup`?\n    if (tiledLayer.type === \"objectgroup\") {\n      tiledLayer.objects.forEach(object => {\n\n        //We're just going to capture the object's properties\n        //so that we can decide what to do with it later\n\n        //Get a reference to the layer group the object is in\n        object.group = layerGroup;\n\n        //Push the object into the world's `objects` array\n        world.objects.push(object);\n      });\n    }\n\n    //I. Add 1 to the z index (the first layer will have a z index of `1`)\n    z += 1;\n  });\n\n  //Search functions\n  //`world.getObject` and `world.getObjects`  search for and return\n  //any sprites or objects in the `world.objects` array.\n  //Any object that has a `name` propery in\n  //Tiled Editor will show up in a search.\n  //`getObject` gives you a single object, `getObjects` gives you an array\n  //of objects.\n  //`getObject` returns the actual search function, so you\n  //can use the following format to directly access a single object:\n  //sprite.x = world.getObject(\"anySprite\").x;\n  //sprite.y = world.getObject(\"anySprite\").y;\n\n  world.getObject = (objectName) => {\n    let searchForObject = () => {\n      let foundObject;\n      world.objects.some(object => {\n        if (object.name && object.name === objectName) {\n          foundObject = object;\n          return true;\n        }\n      });\n      if (foundObject) {\n        return foundObject;\n      } else {\n        throw new Error(\"There is no object with the property name: \" + objectName);\n      }\n    };\n\n    //Return the search function\n    return searchForObject();\n  };\n\n  world.getObjects = (objectNames) => {\n    let foundObjects = [];\n    world.objects.forEach(object => {\n      if (object.name && objectNames.indexOf(object.name) !== -1) {\n        foundObjects.push(object);\n      }\n    });\n    if (foundObjects.length > 0) {\n      return foundObjects;\n    } else {\n      throw new Error(\"I could not find those objects\");\n    }\n    return foundObjects;\n  };\n\n  //That's it, we're done!\n  //Finally, return the `world` object back to the game program\n  return world;\n}\n\nfunction byDepth(a, b) {\n  //Calculate the depths of `a` and `b`\n  //(add `1` to `a.z` and `b.x` to avoid multiplying by 0)\n  a.depth = (a.cartX + a.cartY) * (a.z + 1);\n  b.depth = (b.cartX + b.cartY) * (b.z + 1);\n\n  //Move sprites with a lower depth to a higher position in the array\n  if (a.depth < b.depth) {\n    return -1;\n  } else if (a.depth > b.depth) {\n    return 1;\n  } else {\n    return 0;\n  }\n}\n\nfunction hitTestIsoTile(sprite, mapArray, gidToCheck, world, pointsToCheck) {\n\n  //The `checkPoints` helper function Loop through the sprite's corner points to \n  //find out if they are inside an array cell that you're interested in. \n  //Return `true` if they are\n  let checkPoints = key => {\n\n    //Get a reference to the current point to check.\n    //(`topLeft`, `topRight`, `bottomLeft` or `bottomRight` )\n    let point = sprite.collisionPoints[key];\n\n    //Find the point's index number in the map array\n    //Use the `cartTilewidth` and `cartTileheigh` values if\n    //they've been assigned\n    if (world.cartTilewidth && world.cartTileheight) {\n      collision.index = g.getIndex(\n        point.x, point.y,\n        world.cartTilewidth, world.cartTileheight, world.widthInTiles\n      );\n    } else {\n      collision.index = g.getIndex(\n        point.x, point.y,\n        world.tilewidth, world.tileheight, world.widthInTiles\n      );\n    }\n\n    //Find out what the gid value is in the map position\n    //that the point is currently over\n    collision.gid = mapArray[collision.index];\n\n    //If it matches the value of the gid that we're interested, in\n    //then there's been a collision\n    if (collision.gid === gidToCheck) {\n      return true;\n    } else {\n      return false;\n    }\n  };\n\n  //Assign \"some\" as the default value for `pointsToCheck`\n  pointsToCheck = pointsToCheck || \"some\";\n\n  //The collision object that will be returned by this function\n  let collision = {};\n\n  //Which points do you want to check?\n  //\"every\", \"some\" or \"center\"?\n  switch (pointsToCheck) {\n    case \"center\":\n\n      //`hit` will be true only if the center point is touching\n      let point = {\n        center: {\n          //x: sprite.centerX,\n          //y: sprite.centerY\n          x: s.cartX + ca.x + (ca.width / 2),\n          y: s.cartY + ca.y + (ca.height / 2)\n        }\n      };\n      sprite.collisionPoints = point;\n      collision.hit = Object.keys(sprite.collisionPoints).some(checkPoints);\n      break;\n    case \"every\":\n\n      //`hit` will be true if every point is touching\n      sprite.collisionPoints = getIsoPoints(sprite);\n      collision.hit = Object.keys(sprite.collisionPoints).every(checkPoints);\n      break;\n    case \"some\":\n\n      //`hit` will be true only if some points are touching\n      sprite.collisionPoints = getIsoPoints(sprite);\n      collision.hit = Object.keys(sprite.collisionPoints).some(checkPoints);\n      break;\n  }\n\n  //Return the collision object.\n  //`collision.hit` will be true if a collision is detected.\n  //`collision.index` tells you the map array index number where the\n  //collision occured\n  return collision;\n}\n\nfunction getIsoPoints(s) {\n  let ca = s.collisionArea;\n  if (ca !== undefined) {\n    return {\n      topLeft: {\n        x: s.cartX + ca.x,\n        y: s.cartY + ca.y\n      },\n      topRight: {\n        x: s.cartX + ca.x + ca.width,\n        y: s.cartY + ca.y\n      },\n      bottomLeft: {\n        x: s.cartX + ca.x,\n        y: s.cartY + ca.y + ca.height\n      },\n      bottomRight: {\n        x: s.cartX + ca.x + ca.width,\n        y: s.cartY + ca.y + ca.height\n      }\n    };\n  } else {\n    return {\n      topLeft: {\n        x: s.cartX,\n        y: s.cartY\n      },\n      topRight: {\n        x: s.cartX + s.cartWidth - 1,\n        y: s.cartY\n      },\n      bottomLeft: {\n        x: s.cartX,\n        y: s.cartY + s.cartHeight - 1\n      },\n      bottomRight: {\n        x: s.cartX + s.cartWidth - 1,\n        y: s.cartY + s.cartHeight - 1\n      }\n    };\n  }\n}\n\n\n//Create some useful properties on the pointer\nfunction makeIsoPointer(pointer, world) {\n  Object.defineProperties(pointer, {\n\n    //The isometric's world's Cartesian coordiantes\n    cartX: {\n      get() {\n        return (((2 * this.cartY + this.cartX) - (2 * world.y + world.x)) / 2) - (world.tilewidth / 2);\n      },\n      enumerable: true,\n      configurable: true\n    },\n    cartY: {\n      get() {\n        return (((2 * this.cartY - this.cartX) - (2 * world.y - world.x)) / 2) + (world.tileheight / 2);\n      },\n      enumerable: true,\n      configurable: true\n    },\n\n    //The tile's column and row in the array\n    column: {\n      get() {\n        return Math.floor(this.cartX / world.tilewidth);\n      },\n      enumerable: true,\n      configurable: true\n    },\n    row: {\n      get() {\n        return Math.floor(this.cartY / world.tileheight);\n      },\n      enumerable: true,\n      configurable: true\n    },\n\n    //The tile's index number in the array\n    index: {\n      get() {\n        let index = {};\n\n        //Convert pixel coordinates to map index coordinates\n        index.x = Math.floor(this.cartX / world.tilewidth);\n        index.y = Math.floor(this.cartY / world.tileheight);\n\n        //Return the index number\n        return index.x + (index.y * world.widthInTiles);\n      },\n      enumerable: true,\n      configurable: true\n    },\n  });\n}\n\n//A function for creating a simple isometric diamond\n//shaped rectangle using Pixi's graphics library\nfunction isoRectangle(width, height, fillStyle) {\n\n  //Figure out the `halfHeight` value\n  let halfHeight = height / 2;\n\n  //Draw the flattened and rotated square (diamond shape)\n  let rectangle = new PIXI.Graphics();\n  rectangle.beginFill(fillStyle);\n  rectangle.moveTo(0, 0);\n  rectangle.lineTo(width, halfHeight);\n  rectangle.lineTo(0, height);\n  rectangle.lineTo(-width, halfHeight);\n  rectangle.lineTo(0, 0);\n  rectangle.endFill();\n\n  //Generate a texture from the rectangle\n  let texture = rectangle.generateTexture();\n\n  //Use the texture to create a sprite \n  let sprite = new PIXI.Sprite(texture);\n\n  //Return it to the main program\n  return sprite;\n}\n\n//Add properties to the sprite to help work between Cartesian\n//and isometric properties\nfunction addIsoProperties(sprite, x, y, width, height) {\n\n  //Cartisian (flat 2D) properties\n  sprite.cartX = x;\n  sprite.cartY = y;\n  sprite.cartWidth = width;\n  sprite.cartHeight = height;\n\n  //Add a getter/setter for the isometric properties\n  Object.defineProperties(sprite, {\n    isoX: {\n      get() {\n        return this.cartX - this.cartY;\n      },\n      enumerable: true,\n      configurable: true\n    },\n    isoY: {\n      get() {\n        return (this.cartX + this.cartY) / 2;\n      },\n      enumerable: true,\n      configurable: true\n    },\n  });\n};\n\n//A function for converting a Cartsian x and y point\n//to an isometric point\n//(This is unused in this example)\nfunction isoPoint(x, y) {\n  let point = {};\n  point.x = x - y;\n  point.y = (x + y) / 2;\n  return point;\n}"]}