{"version":3,"sources":["../src/cartesian.js"],"names":[],"mappings":"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","file":"cartesian.js","sourcesContent":["//Create a new Hexi instance, and start it.\nlet g = hexi(512, 512, setup);\n\n//Scale the canvas to the maximum browser dimensions\ng.scaleToWindow();\n\n//Start Hexi\ng.start();\n\n\nfunction setup() {\n\n  //Create the `world` container that defines our isometric \n  //tile-based world\n  let world = g.group();\n\n  //Set the `tileWidth` and `tileHeight` of each tile, in pixels\n  world.cartTilewidth = 32;\n  world.cartTileheight = 32;\n\n  //Define the width and height of the world, in tiles\n  world.widthInTiles = 8;\n  world.heightInTiles = 8;\n\n  //Create the world layers\n  world.layers = [\n\n    //The environment layer. `2` represents the walls,\n    //`1` represents the floors\n    [\n      2, 2, 2, 2, 2, 2, 2, 2,\n      2, 1, 1, 1, 1, 1, 1, 2,\n      2, 1, 2, 1, 1, 2, 1, 2,\n      2, 1, 1, 1, 1, 2, 2, 2,\n      2, 1, 1, 1, 1, 1, 1, 2,\n      2, 2, 2, 1, 2, 1, 1, 2,\n      2, 1, 1, 1, 1, 1, 1, 2,\n      2, 2, 2, 2, 2, 2, 2, 2\n    ],\n\n    //The character layer. `3` represents the game character\n    //`0` represents an empty cell which won't contain any\n    //sprites\n    [\n      0, 0, 0, 0, 0, 0, 0, 0,\n      0, 0, 0, 0, 0, 0, 0, 0,\n      0, 0, 0, 0, 0, 0, 0, 0,\n      0, 0, 0, 0, 0, 0, 0, 0,\n      0, 0, 0, 0, 3, 0, 0, 0,\n      0, 0, 0, 0, 0, 0, 0, 0,\n      0, 0, 0, 0, 0, 0, 0, 0,\n      0, 0, 0, 0, 0, 0, 0, 0\n    ]\n  ];\n\n  //Build the game world by looping through each \n  //of the layers arrays one after the other\n  world.layers.forEach(layer => {\n\n    //Loop through each array element\n    layer.forEach((gid, index) => {\n\n      //If the cell isn't empty (0) then create a sprite\n      if (gid !== 0) {\n\n        //Find the column and row that the sprite is on and also\n        //its x and y pixel values that match column and row position\n        let column, row, x, y;\n        column = index % world.widthInTiles;\n        row = Math.floor(index / world.widthInTiles);\n        x = column * world.cartTilewidth;\n        y = row * world.cartTileheight;\n\n        //Next, create a different sprite based on what its \n        //`gid` number is\n        let sprite;\n        switch (gid) {\n\n          //The floor\n          case 1:\n            sprite = g.rectangle(world.cartTilewidth, world.cartTileheight, 0xCCCCFF);\n            break;\n\n            //The walls\n          case 2:\n            sprite = g.rectangle(world.cartTilewidth, world.cartTileheight, 0x99CC00);\n            break;\n\n            //The character  \n          case 3:\n            sprite = g.rectangle(world.cartTilewidth, world.cartTileheight, 0xFF0000);\n        }\n\n        //Position the sprite using the calculated `x` and `y` values\n        //that match its column and row in the tile map\n        sprite.x = x;\n        sprite.y = y;\n\n        //Add the sprite to the `world` container\n        world.addChild(sprite);\n      }\n    });\n  });\n}"]}