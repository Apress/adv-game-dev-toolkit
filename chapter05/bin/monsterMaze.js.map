{"version":3,"sources":["../src/monsterMaze.js"],"names":[],"mappings":"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","file":"monsterMaze.js","sourcesContent":["let thingsToLoad = [\n  \"images/monsterMaze.png\",\n  \"maps/monsterMaze.json\"\n];\n\n//Create a new Hexi instance, and start it.\nlet g = hexi(704, 512, setup, thingsToLoad);\n\n//Set the background color and scale the canvas\n//g.backgroundColor = \"black\";\ng.scaleToWindow();\n\n//Start Hexi\ng.start();\n\n//Game variables\nlet world, alien, message, wallMapArray,\n  bombMapArray, bombSprites, bombLayer,\n  leftArrow, upArrow, downArrow, rightArrow;\n\n//The `setup` function to initialize your application\nfunction setup() {\n\n  //Make the world from the Tiled JSON data and the tileset PNG image\n  world = g.makeTiledWorld(\n    \"maps/monsterMaze.json\",\n    \"images/monsterMaze.png\"\n  );\n\n  /*\n  Get a reference to the `alien` sprite.\n  Use `world.getObject` to do this. `getObject` searches for and\n  returns a sprite in the `world` that has a `name` property that\n  matches the string in the argument.\n  */\n  alien = world.getObject(\"alien\");\n\n  /*\n  Each Tiled Editor layer has a `name` that can be accessed in your\n  game code using\n  `world.getObject` Tiled Editor's `tilelayers` have a `data` property\n  that is an array containing all the grid index numbers (`gid`) of\n  the tiles in that array. In this example we want to access all the\n  wall sprites. In Tiled Editor, all the wall sprites were added to \n  a tile layer called `wallLayer`. We can access the `wallLayer`'s\n  `data` array of sprites like this: \n  */\n\n  wallMapArray = world.getObject(\"wallLayer\").data;\n\n  /*\n  We also need a reference to the bomb layer. All Tiled Editor layers are \n  created as `groups` by Hexi's `makeTiledWorld` method. That means they\n  all have a `children` array that lets' you access all the sprites on\n  that layer, if you even need to do that. \n  */\n\n  monsterLayer = world.getObject(\"monsterLayer\");\n\n  //Get a reference to the level's monster layer array. This is the\n  //monster layer's `data` array\n\n  monsterMapArray = monsterLayer.data;\n\n  /*\n  You can use `world.getObjects` (with an \"s\") to get an array of all\n  the things in the world that have the same `name` properties. There\n  are 5 bombs in the world, all which have share the same `name`\n  property: \"bomb\". Here's how you can access to all of them in an\n  array:\n  */\n\n  monsterSprites = world.getObjects(\"monsterClosed\");\n  console.log(monsterSprites)\n\n  //`bombSprites` is now an array that contains all the bomb sprites\n  //in the world\n\n  //Give the `alien` a `direction` property\n  alien.direction = \"\";\n\n  //Configure Hexi's built in arrow keys to assign the alien a direction\n  //Create some keyboard objects\n  leftArrow = g.keyboard(37);\n  upArrow = g.keyboard(38);\n  rightArrow = g.keyboard(39);\n  downArrow = g.keyboard(40);\n\n  //Program the keyboard objects\n  leftArrow.press = () => alien.direction = \"left\";\n  upArrow.press = () => alien.direction = \"up\";\n  rightArrow.press = () => alien.direction = \"right\";\n  downArrow.press = () => alien.direction = \"down\";\n\n  //Change the game state to `play`\n  g.state = play;\n}\n\n//The `play` function contains all the game logic and runs in a loop\nfunction play() {\n\n  //Change the alien's direction only if it's at an intersection\n  //(This keeps it aligned to the grid cells. You don't have to do\n  //this but it's a nice effect that you might want to use in your\n  //own games at some point.)\n\n  if (isAtIntersection(alien)) {\n    switch (alien.direction) {\n      case \"up\":\n        alien.vy = -4;\n        alien.vx = 0;\n        break;\n      case \"down\":\n        alien.vy = 4;\n        alien.vx = 0;\n        break;\n      case \"left\":\n        alien.vx = -4;\n        alien.vy = 0;\n        break;\n      case \"right\":\n        alien.vx = 4;\n        alien.vy = 0;\n        break;\n      case \"none\":\n        alien.vx = 0;\n        alien.vy = 0;\n        break;\n    }\n  }\n\n  //Move the alien\n  g.move(alien);\n\n  //Keep the alien contained inside the canvas\n  //g.contain(alien, g.stage);\n\n  /*\n  Prevent the alien from walking through walls using the \n  versatile `hitTestTile` method. `hitTestTile` checks for a\n  collision between a sprite and a tile in any map array that you\n  specify. It returns a `collision` object. \n  `collision.hit` is a Boolean that tells you if a sprite is colliding\n  with the tile that you're checking. `collision.index` tells you the\n  map array's index number of the colliding sprite. You can check for\n  a collision with the tile against \"every\" corner point on the\n  sprite, \"some\" corner points, or the sprite's \"center\" point. (Each\n  of these three options has a different and useful effect, so experiment with\n  them.)\n\n  `hitTestTile` arguments:\n  sprite, array, collisionTileGridIdNumber, worldObject, spritesPointsToCheck \n\n  The `world` object (the 4th argument) has to have these properties:\n  `tileheight`, `tilewidth`, `widthInTiles`.\n\n  `hitTestTile` will work for any map array, not just those made with\n  Tiled Editor. So you can use it with your own game maps in the same way.\n\n  */\n\n  let alienVsFloor = g.hitTestTile(alien, wallMapArray, 0, world, \"every\");\n\n  //If every corner point on the alien isn't touching a floor tile (array gridIDNumber: 0) then\n  //prevent the alien from moving\n  //\n  if (!alienVsFloor.hit) {\n\n    //To prevent the alien from moving, subtract its velocity from its position\n    alien.x -= alien.vx;\n    alien.y -= alien.vy;\n    alien.vx = 0;\n    alien.vy = 0;\n  }\n  /*\n  //Check for a collision between the alien and the bombs\n  let alienVsBomb = g.hitTestTile(alien, bombMapArray, 5, world, \"every\");\n\n  //Find out if the alien's position in the bomb array matches a bomb gid number\n  if (alienVsBomb.hit) {\n\n    //If it does, filter through the bomb sprites and find the one\n    //that matches the alien's position\n    bombSprites = bombSprites.filter(function(bomb) {\n\n      //Does the bomb sprite have the same index number as the alien?\n      if (bomb.index === alienVsBomb.index) {\n\n        //If it does, remove the bomb from the \n        //`bombMapArray` by setting its gid to `0`\n        bombMapArray[bomb.index] = 0;\n\n        //Remove the bomb sprite from its container group\n        g.remove(bomb);\n\n        //Alternatively, remove the bomb with `removeChild` on\n        //the `bombLayer` group\n        //bombLayer.removeChild(bomb);\n        //Filter the bomb out of the `bombSprites` array\n        return false;\n      } else {\n\n        //Keep the bomb in the `bombSprites` array if it doesn't match\n        return true;\n      }\n    });\n  }\n  */\n}\n\n//Helper functions\n\n//`isAtIntersection` returns true or false depending on whether a \n//sprite is exactly aligned to anintersection in the maze corridors\nfunction isAtIntersection(sprite) {\n  let trueOrFalse =\n    Math.floor(alien.x) % world.tilewidth === 0 && Math.floor(alien.y) % world.tileheight === 0\n  return trueOrFalse;\n}"]}