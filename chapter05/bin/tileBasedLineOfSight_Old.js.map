{"version":3,"sources":["../src/tileBasedLineOfSight_Old.js"],"names":[],"mappings":"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","file":"tileBasedLineOfSight_Old.js","sourcesContent":["let thingsToLoad = [\n  \"images/monsterMaze.png\",\n  \"maps/monsterMaze.json\"\n];\n\n//Create a new Hexi instance, and start it.\nlet g = hexi(704, 512, setup, thingsToLoad);\n\n//Set the background color and scale the canvas\n//g.backgroundColor = \"black\";\ng.scaleToWindow();\n\n//Start Hexi\ng.start();\n\n//Game variables\nlet world, alien, message, wallMapArray,\n  bombMapArray, bombSprites, bombLayer,\n  leftArrow, upArrow, downArrow, rightArrow;\n\n//The `setup` function to initialize your application\nfunction setup() {\n\n  //Make the world from the Tiled JSON data and the tileset PNG image\n  world = g.makeTiledWorld(\n    \"maps/monsterMaze.json\",\n    \"images/monsterMaze.png\"\n  );\n\n  //Create the alien sprite and set its speed\n  alien = world.getObject(\"alien\");\n  alien.speed = 4\n\n  //Get a reference to the array that stores all the wall data\n  wallMapArray = world.getObject(\"wallLayer\").data;\n\n  //We're just using the monsters sprites in the Tiled Editor\n  //map as generic placeholders.  We're going to use their size and\n  //position data to build new monster sprites from scratch and place\n  //them in the world. That's because we want to give the monsters\n  //custom animation frames. Here's how to do this:\n\n  //1. Get a reference to the map's monster sprites and the \n  //layer container that those sprites are one\n  let mapMonsters = world.getObjects(\"monster\");\n  let monsterLayer = world.getObject(\"monsterLayer\");\n\n  //2.Define the monster's animation frames. In this example there are just\n  //two: the monster mouth open, and the monster's mouth closed.\n  monsterFrames = g.frames(\n    \"images/monsterMaze.png\", //The tileset image\n    [\n      [128, 0],\n      [128, 64]\n    ], //The `x` and `y` positions of frames\n    64, 64 //The `width` and `height` of each frame\n  );\n\n  //3.Create a new array called `monsters` that contains a new `monster`\n  //sprite for each `mapMonster` in the original array. The new\n  //`monster` sprites are created using the `monsterFrames` we defined\n  //above and have the same `x` and `y` positions as the original\n  //placeholder monsters from the Tiled Editor map. We're also going\n  //to give them new `direction` and `speed`. Finally, we need to make the \n  //placeholder monsters invisible and add the new `monster` sprite\n  //to the `monsterLayer` container. \n  monsters = mapMonsters.map(mapMonster => {\n    let monster = g.sprite(monsterFrames);\n    monster.x = mapMonster.x;\n    monster.y = mapMonster.y;\n    monster.direction = \"none\";\n    monster.speed = 4;\n    monsterLayer.addChild(monster);\n    mapMonster.visible = false;\n\n    //Define the monster's two states: `normal` and `scared`\n    //`0` and `1` refer to the monster's two animation frames\n    monster.states = {\n      normal: 0,\n      scared: 1\n    };\n    return monster;\n  });\n\n  //Give the `alien` a `direction` property and initilize it to \"none\"\n  alien.direction = \"none\";\n\n  //Configure Hexi's built in arrow keys to assign the alien a direction\n  //Create some keyboard objects\n  leftArrow = g.keyboard(37);\n  upArrow = g.keyboard(38);\n  rightArrow = g.keyboard(39);\n  downArrow = g.keyboard(40);\n\n  //Program the keyboard objects\n  leftArrow.press = () => alien.direction = \"left\";\n  upArrow.press = () => alien.direction = \"up\";\n  rightArrow.press = () => alien.direction = \"right\";\n  downArrow.press = () => alien.direction = \"down\";\n\n  //Change the game state to `play`\n  g.state = play;\n}\n\n//The `play` function contains all the game logic and runs in a loop\nfunction play() {\n\n  //Change the alien's direction if it's directly centered\n  //over a tile cell\n\n  if (isCenteredOverCell(alien)) {\n    let velocity = directionToVelocity(alien.direction, alien.speed);\n    alien.vx = velocity.vx;\n    alien.vy = velocity.vy;\n  }\n\n  //Move the alien\n  g.move(alien);\n\n  //Check for a collision between the alien and the floor\n  let alienVsFloor = g.hitTestTile(alien, wallMapArray, 0, world, \"every\");\n\n  //If every corner point on the alien isn't touching a floor \n  //tile (array gridIDNumber: 0) then prevent the alien from moving\n  if (!alienVsFloor.hit) {\n\n    //To prevent the alien from moving, subtract its velocity from its position\n    alien.x -= alien.vx;\n    alien.y -= alien.vy;\n    alien.vx = 0;\n    alien.vy = 0;\n  }\n\n  monsters.forEach(monster => {\n\n    //Is the monster directly centered over a map tile cell?\n    if (isCenteredOverCell(monster)) {\n\n      //Yes, it is, so give it a new random direction\n      monster.direction = findDirection(\n        monster, monster.direction, alien, wallMapArray, world\n      );\n\n      //Use the monster's direction and speed to find its \n      //new velocity\n      let velocity = directionToVelocity(monster.direction, monster.speed);\n      monster.vx = velocity.vx;\n      monster.vy = velocity.vy;\n    }\n\n    //Move the monster\n    g.move(monster);\n\n    //Change the monster's state\n\n    //1. Plot a vector between the monster and the alien\n    let vx = alien.centerX - monster.centerX,\n      vy = alien.centerY - monster.centerY;\n\n    //3. If the monster can see the alien,\n    //change the monster's state to `scared`. Otherwise, set its\n    //state to `normal`\n    monster.lineOfSight = tileBasedLineOfSight(\n      monster,\n      alien,\n      wallMapArray,\n      world,\n      0, [90, -90, 0, 180, -180]\n    );\n\n    if (monster.lineOfSight) {\n      monster.show(monster.states.scared)\n    } else {\n      monster.show(monster.states.normal)\n    }\n  });\n}\n\n//Helper functions\n\n//`isAtIntersection` returns true or false depending on whether a \n//sprite is exactly aligned to anintersection in the maze corridors\nfunction isCenteredOverCell(sprite) {\n  let trueOrFalse =\n    Math.floor(sprite.x) % world.tilewidth === 0 && Math.floor(sprite.y) % world.tileheight === 0\n  return trueOrFalse;\n}\n\nfunction directionToVelocity(direction = \"none\", speed = 0) {\n\n  //Change the sprite's velocity if it's centered \n  //over a tile grid cell \n  switch (direction) {\n    case \"up\":\n      return {\n        vy: -speed,\n        vx: 0\n      }\n      break;\n    case \"down\":\n      return {\n        vy: speed,\n        vx: 0\n      };\n      break;\n    case \"left\":\n      return {\n        vx: -speed,\n        vy: 0\n      };\n      break;\n    case \"right\":\n      return {\n        vx: speed,\n        vy: 0\n      };\n      break;\n    case \"none\":\n      return {\n        vx: 0,\n        vy: 0\n      };\n  }\n};\n\nfunction changeDirection(sprite, direction, speed) {\n\n  //Change the sprite's velocity if it's centered \n  //over a tile grid cell \n  switch (direction) {\n    case \"up\":\n      sprite.vy = -speed;\n      sprite.vx = 0;\n      break;\n    case \"down\":\n      sprite.vy = speed;\n      sprite.vx = 0;\n      break;\n    case \"left\":\n      sprite.vx = -speed;\n      sprite.vy = 0;\n      break;\n    case \"right\":\n      sprite.vx = speed;\n      sprite.vy = 0;\n      break;\n    case \"none\":\n      sprite.vx = 0;\n      sprite.vy = 0;\n      break;\n  }\n};\n\nfunction surroundingCrossCells(index, widthInTiles) {\n  return [\n    index - widthInTiles,\n    index - 1,\n    index + 1,\n    index + widthInTiles,\n  ];\n}\n\nfunction surroundingDiagonalCells(index, widthInTiles) {\n  return [\n    index - widthInTiles - 1,\n    index - widthInTiles + 1,\n    index + widthInTiles - 1,\n    index + widthInTiles + 1,\n  ];\n}\n\nfunction findValidDirections(sprite, mapArray, validGid, world) {\n\n  //Get the sprite's current map index position number\n  let index = g.getIndex(\n    sprite.x,\n    sprite.y,\n    world.tilewidth,\n    world.tileheight,\n    world.widthInTiles\n  );\n\n  //Get the index position numbers of the 4 cells to the top, right, left\n  //and bottom of the sprite\n  let surroundingIndexNumbers = surroundingCrossCells(index, world.widthInTiles);\n\n  //Find all the tiles that match the surrounding index numbers\n  let surroundingTiles = surroundingIndexNumbers.map(indexNumber => {\n    return g.getTile(indexNumber, mapArray, world);\n  });\n\n  //Floor tiles have a gid value of 0, and are a valid tiles for the sprite\n  //to travel on. 0 is the `validGid` value in this example. \n  //`validTiles` is an array of true/false values where each\n  //valid direction tile (a floor tile) will be represented as `true`\n  let validTiles = surroundingTiles.map(tile => {\n    return tile.gid === validGid;\n  });\n\n  //`directionList` is an array of 4 string values that can be either\n  //\"up\", \"left\", \"right\", \"down\" or \"none\", depending on \n  //whether there is a `validTile` that matches that direction.\n  let directionList = validTiles.map((validTile, i) => {\n\n    //The possible directions\n    let possibleDirections = [\"up\", \"left\", \"right\", \"down\"];\n\n    //If the direction is valid, choose the matching string \n    //identifier for that direction. Otherwise, return \"none\"\n    if (validTile) {\n      return possibleDirections[i];\n    } else {\n      return \"none\";\n    }\n  });\n\n  //We don't need \"none\" in the list of directions, so \n  //let's filter it out\n  let filteredDirectionList = directionList.filter(direction => direction != \"none\");\n\n  //Return the filtered list of valid directions\n  return filteredDirectionList;\n}\n\nfunction tileBasedLineOfSight(\n  spriteOne, //The first sprite, with `centerX` and `centerY` properties\n  spriteTwo, //The second sprite, with `centerX` and `centerY` properties\n  mapArray, //The tile map array\n  world, //The `world` object that contains the `tilewidth\n  //`tileheight` and `widthInTiles` properties\n  emptyGid = 0, //The Gid that represents and empty tile, usually `0`\n  angles = [] //An array of angles to which you want to \n  //restrict the line of sight\n) {\n\n  //Plot a vector between spriteTwo and spriteOne\n  let vx = spriteTwo.centerX - spriteOne.centerX,\n    vy = spriteTwo.centerY - spriteOne.centerY;\n\n  //Find the vector's magnitude (its length in pixels)\n  let magnitude = Math.sqrt(vx * vx + vy * vy);\n\n  let angle = Math.atan2(vy, vx) * 180 / Math.PI;\n\n  //Find the unit vector. This is a small, scaled down version of\n  //the vector between the sprites that's less than one pixel long.\n  //It points in the same direction as the main vector, but because it's\n  //the smallest size that the vector can be, we can use it to create\n  //new vectors or varying length\n  let dx = vx / magnitude,\n    dy = vy / magnitude;\n\n  //We need to test points along the vector between the two sprites.\n  //To do that, we need to find out how much space should be between\n  //each of those points. In this example, the space between points will\n  //be the same as the width of a tile cell (64 pixels)\n  let segment = world.tilewidth;\n\n  //How many points will we need to test?\n  let numberOfPoints = magnitude / segment;\n\n  //Create an array of x/y points, separated by 64 pixels, that\n  //extends from `spriteOne` to `spriteTwo`  \n  let points = () => {\n\n    //Initialize an array that is going to store all our points\n    //along the vector\n    let arrayOfPoints = [];\n\n    //Create a point object for each segment of the vector and \n    //store its x/y position as well as its index number on\n    //the map array \n    for (let i = 1; i <= numberOfPoints; i++) {\n      let newMagnitude = segment * i;\n      let x = spriteOne.centerX + dx * newMagnitude;\n      let y = spriteOne.centerY + dy * newMagnitude;\n      let index = g.getIndex(\n        x, y,\n        world.tilewidth,\n        world.tileheight,\n        world.widthInTiles\n      );\n      let point = {\n        x: x,\n        y: y,\n        index: index\n      };\n      arrayOfPoints.push(point);\n    }\n    return arrayOfPoints;\n  };\n\n  //The `noObstacles` function will return `true` if all the tile\n  //index numbers along the vector are `0`, which means they contain \n  //no walls. If any of them aren't 0, then the function returns\n  //`false` which means there's a wall in the way \n  let noObstacles = points().every(point => mapArray[point.index] === emptyGid);\n\n  //Restrict the line of sight to right angles only (we don't want to\n  //need diagonals)\n\n  let validAngle = () => {\n    if (angles.length !== 0) {\n      return angles.some(x => x === angle);\n    } else {\n      return true;\n    }\n  };\n\n  if (noObstacles === true && validAngle() === true) {\n    return true;\n  } else {\n    return false;\n  }\n\n  //points().forEach(point => console.log(mapArray[point.index]));\n\n  //To check for line of sight in a non-tile based game world,\n  //you could alternatively do a standard \"point vs. rectangle\" collision\n  //check using x/y coordinates. Just test each x/y point in the\n  //`points` array for a collision with a wall sprite. If you don't\n  //find a collision, then you know you have line of sight. \n}\n\nfunction findDirection(spriteOne, spriteOneDirection, spriteTwo, mapArray, world) {\n\n  //Get the sprite's list of valid directions and the values it needs\n  //to understand the kind of map environment that it's in\n  let validDirections = findValidDirections(spriteOne, mapArray, 0, world);\n  let inUpOrDownPassage = validDirections.indexOf(\"up\") !== -1 || validDirections.indexOf(\"down\") !== -1;\n  let inLeftOrRightPassage = validDirections.indexOf(\"left\") !== -1 || validDirections.indexOf(\"right\") !== -1;\n  let inCulDeSac = validDirections.length === 1;\n  let trapped = validDirections.length === 0;\n\n  let hasLineOfSight = tileBasedLineOfSight(\n    spriteOne, //The first sprite\n    spriteTwo, //The second sprite\n    mapArray, //The tile map array\n    world, //The `world` object\n    0, //The Gid that represents and empty tile\n    [90, -90, 0, 180, -180] //The angles to limit the line-of-sight\n  );\n\n  //Randomly select one of the valid directions\n  let randomDirection = () => {\n    if (!trapped) {\n      return validDirections[g.randomInt(0, validDirections.length - 1)];\n    } else {\n      return \"none\"\n    }\n  };\n\n  //Find the closest direction\n  let closestDirection = () => {\n\n    //Plot a vector between spriteTwo and spriteOne\n    let vx = spriteTwo.centerX - spriteOne.centerX,\n      vy = spriteTwo.centerY - spriteOne.centerY;\n\n    //If the distance is greater on the X axis...\n    if (Math.abs(vx) >= Math.abs(vy)) {\n\n      //Try left and right\n      if (vx <= 0) {\n        return \"left\";\n      } else {\n        return \"right\";\n      }\n    }\n    //If the distance is greater on the Y axis...\n    else {\n      //Try up and down\n      if (vy <= 0) {\n        return \"up\"\n      } else {\n        return \"down\"\n      }\n    }\n  };\n\n  //Return `true` if the closest direction is also a valid direction\n  let closestDirectionIsValid = validDirections.indexOf(closestDirection()) !== -1;\n\n  //Check to make sure the sprite is at a location on the map where\n  //it can change its direction.\n  //Return the `closestDirection` if it's also a valid direction,\n  //otherwise choose a new random direction.\n  //If the sprite is not at a location where it can change its direction,\n  //just return the same direction that it had before\n  if (!trapped) {\n    if (inLeftOrRightPassage && inUpOrDownPassage || inCulDeSac) {\n      if (closestDirectionIsValid && hasLineOfSight) {\n        return closestDirection();\n      } else {\n        return randomDirection();\n      }\n    } else {\n      return spriteOneDirection;\n    }\n  } else {\n    return spriteOneDirection;\n  }\n}"]}