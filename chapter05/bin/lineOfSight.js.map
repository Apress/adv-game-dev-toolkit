{"version":3,"sources":["../src/lineOfSight.js"],"names":[],"mappings":"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","file":"lineOfSight.js","sourcesContent":["let thingsToLoad = [\n  \"images/alien.png\",\n  \"images/monsterNormal.png\",\n  \"images/monsterAngry.png\"\n];\n\n//Create a new Hexi instance, and start it.\nlet g = hexi(704, 512, setup, thingsToLoad);\n\n//Set the background color and scale the canvas\n//g.backgroundColor = \"black\";\ng.scaleToWindow();\n\n//Start Hexi\ng.start();\n\n//Game variables\nlet alien, monster, boxes;\n\n//The `setup` function to initialize your application\nfunction setup() {\n\n  //Create the alien using the `alienFrames`\n  alien = g.sprite(\"images/alien.png\");\n\n  //Center the alien on the left side of the canvas\n  g.stage.putCenter(alien, -g.canvas.width / 4);\n\n  //Create the monster sprite using the `monsterFrames`\n  monster = g.sprite([\n    \"images/monsterNormal.png\",\n    \"images/monsterAngry.png\"\n  ]);\n\n  //Define the monster's two states: `normal` and `scared`\n  //`0` and `1` refer to the monster's two animation frames\n  monster.states = {\n    normal: 0,\n    angry: 1\n  };\n\n  //Center the monster on the right side of the canvas\n  g.stage.putCenter(monster, g.canvas.width / 4);\n\n  //Create the boxes\n  boxes = [];\n  let numberOfboxes = 4;\n  for (let i = 0; i < numberOfboxes; i++) {\n    boxes.push(g.sprite(\"images/box.png\"));\n  }\n\n  //Position the boxes in a square shape around the \n  //center of the canvas\n  g.stage.putCenter(boxes[0], -32, -64);\n  g.stage.putCenter(boxes[1], 32, -64);\n  g.stage.putCenter(boxes[2], -32)\n  g.stage.putCenter(boxes[3], 32);\n\n  //Switch on drag-and-drop for all the sprites\n  alien.draggable = true;\n  monster.draggable = true;\n  boxes.forEach(wall => wall.draggable = true);\n\n  //Create a `line` sprite.\n  //`line` arguments:\n  //strokeStyle, lineWidth, ax, ay, bx, by\n  //`ax` and `ay` define the line's start x/y point,\n  //`bx`, `by` define the line's end x/y point.\n  line = g.line(\n    \"red\",\n    4,\n    monster.centerX,\n    monster.centerY,\n    alien.centerX,\n    alien.centerY\n  );\n\n  //Set the line's alpha to 0.3\n  line.alpha = 0.3\n\n  let message = g.text(\"Drag and drop the sprites\", \"16px Futura\", \"black\");\n  message.x = 30;\n  message.y = 10;\n\n  //Change the game state to `play`\n  g.state = play;\n}\n\n//The `play` function contains all the game logic and runs in a loop\nfunction play() {\n\n  //Update the position of the line\n  line.ax = monster.centerX;\n  line.ay = monster.centerY;\n  line.bx = alien.centerX;\n  line.by = alien.centerY;\n\n  //Check whether the monster can see the alien by setting its \n  //`lineOfSight` property. `lineOfSight` will be `true` if there\n  //are no boxes obscuring the view, and `false` if there are\n  monster.lineOfSight = lineOfSight(\n    monster, //Sprite one\n    alien, //Sprite two\n    boxes, //An array of obstacle sprites\n    16 //The distance between each collision point\n  );\n\n  //If the monster has line of sight, set its state to \"angry\" and \n  if (monster.lineOfSight) {\n    monster.show(monster.states.angry)\n    line.alpha = 1;\n  } else {\n    monster.show(monster.states.normal)\n    line.alpha = 0.3;\n  }\n\n}\n\n//Helper functions\nfunction lineOfSight(\n  spriteOne, //The first sprite, with `centerX` and `centerY` properties\n  spriteTwo, //The second sprite, with `centerX` and `centerY` properties\n  obstacles, //An array of sprites which act as obstacles\n  segment = 32 //The distance between collision points\n) {\n\n  //Plot a vector between spriteTwo and spriteOne\n  let vx = spriteTwo.centerX - spriteOne.centerX,\n    vy = spriteTwo.centerY - spriteOne.centerY;\n\n  //Find the vector's magnitude (its length in pixels)\n  let magnitude = Math.sqrt(vx * vx + vy * vy);\n\n  //How many points will we need to test?\n  let numberOfPoints = magnitude / segment;\n\n  //Create an array of x/y points, separated by 64 pixels, that\n  //extends from `spriteOne` to `spriteTwo`  \n  let points = () => {\n\n    //Initialize an array that is going to store all our points\n    //along the vector\n    let arrayOfPoints = [];\n\n    //Create a point object for each segment of the vector and \n    //store its x/y position as well as its index number on\n    //the map array \n    for (let i = 1; i <= numberOfPoints; i++) {\n\n      //Calculate the new magnitude for this iteration of the loop\n      let newMagnitude = segment * i;\n\n      //Find the unit vector. This is a small, scaled down version of\n      //the vector between the sprites that's less than one pixel long.\n      //It points in the same direction as the main vector, but because it's\n      //the smallest size that the vector can be, we can use it to create\n      //new vectors of varying length\n      let dx = vx / magnitude,\n        dy = vy / magnitude;\n\n      //Use the unit vector and newMagnitude to figure out the x/y\n      //position of the next point in this loop iteration\n      let x = spriteOne.centerX + dx * newMagnitude,\n        y = spriteOne.centerY + dy * newMagnitude;\n\n      //Push a point object with x and y properties into the `arrayOfPoints`\n      arrayOfPoints.push({\n        x, y\n      });\n    }\n\n    //Return the array of point objects\n    return arrayOfPoints;\n  };\n\n  //Test for a collision between a point and a sprite\n  let hitTestPoint = (point, sprite) => {\n\n    //Find out if the point's position is inside the area defined\n    //by the sprite's left, right, top and bottom sides\n    let left = point.x > sprite.x,\n      right = point.x < (sprite.x + sprite.width),\n      top = point.y > sprite.y,\n      bottom = point.y < (sprite.y + sprite.height);\n\n    //If all the collision conditions are met, you know the\n    //point is intersecting the sprite\n    return left && right && top && bottom;\n  };\n\n  //The `noObstacles` function will return `true` if all the tile\n  //index numbers along the vector are `0`, which means they contain \n  //no obstacles. If any of them aren't 0, then the function returns\n  //`false` which means there's an obstacle in the way \n  let noObstacles = points().every(point => {\n    return obstacles.every(obstacle => {\n      return !(hitTestPoint(point, obstacle))\n    });\n  });\n\n  //Return the true/false value of the collision test\n  return noObstacles;\n}"]}