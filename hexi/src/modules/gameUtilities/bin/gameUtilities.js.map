{"version":3,"sources":["../src/gameUtilities.js"],"names":[],"mappings":"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","file":"gameUtilities.js","sourcesContent":["class GameUtilities {\n  constructor() {}\n\n  /*\n  distance\n  ----------------\n\n  Find the distance in pixels between two sprites.\n  Parameters: \n  a. A sprite object. \n  b. A sprite object. \n  The function returns the number of pixels distance between the sprites.\n\n     let distanceBetweenSprites = gu.distance(spriteA, spriteB);\n\n  */\n\n  distance(s1, s2) {\n    let vx = (s2.x + this._getCenter(s2, s2.width, \"x\")) - (s1.x + this._getCenter(s1, s1.width, \"x\")),\n        vy = (s2.y + this._getCenter(s2, s2.height, \"y\")) - (s1.y + this._getCenter(s1, s1.height, \"y\"));\n    return Math.sqrt(vx * vx + vy * vy);\n  }\n\n  /*\n  followEase\n  ----------------\n\n  Make a sprite ease to the position of another sprite.\n  Parameters: \n  a. A sprite object. This is the `follower` sprite.\n  b. A sprite object. This is the `leader` sprite that the follower will chase.\n  c. The easing value, such as 0.3. A higher number makes the follower move faster.\n\n     gu.followEase(follower, leader, speed);\n\n  Use it inside a game loop.\n  */\n\n  followEase(follower, leader, speed) {\n\n    //Figure out the distance between the sprites\n    /*\n    let vx = (leader.x + leader.width / 2) - (follower.x + follower.width / 2),\n        vy = (leader.y + leader.height / 2) - (follower.y + follower.height / 2),\n        distance = Math.sqrt(vx * vx + vy * vy);\n    */\n\n    let vx = (leader.x + this._getCenter(leader, leader.width, \"x\")) - (follower.x + this._getCenter(follower, follower.width, \"x\")),\n        vy = (leader.y + this._getCenter(leader, leader.height, \"y\")) - (follower.y + this._getCenter(follower, follower.height, \"y\")),\n        distance = Math.sqrt(vx * vx + vy * vy);\n\n    //Move the follower if it's more than 1 pixel\n    //away from the leader\n    if (distance >= 1) {\n      follower.x += vx * speed;\n      follower.y += vy * speed;\n    }\n  }\n\n  /*\n  followConstant\n  ----------------\n\n  Make a sprite move towards another sprite at a constant speed.\n  Parameters: \n  a. A sprite object. This is the `follower` sprite.\n  b. A sprite object. This is the `leader` sprite that the follower will chase.\n  c. The speed value, such as 3. The is the pixels per frame that the sprite will move. A higher number makes the follower move faster.\n\n     gu.followConstant(follower, leader, speed);\n\n  */\n\n  followConstant(follower, leader, speed) {\n\n    //Figure out the distance between the sprites\n    let vx = (leader.x + this._getCenter(leader, leader.width, \"x\")) - (follower.x + this._getCenter(follower, follower.width, \"x\")),\n        vy = (leader.y + this._getCenter(leader, leader.height, \"y\")) - (follower.y + this._getCenter(follower, follower.height, \"y\")),\n        distance = Math.sqrt(vx * vx + vy * vy);\n\n    //Move the follower if it's more than 1 move\n    //away from the leader\n    if (distance >= speed) {\n      follower.x += (vx / distance) * speed;\n      follower.y += (vy / distance) * speed;\n    }\n  }\n\n  /*\n  angle\n  -----\n\n  Return the angle in Radians between two sprites.\n  Parameters: \n  a. A sprite object.\n  b. A sprite object.\n  You can use it to make a sprite rotate towards another sprite like this:\n\n      box.rotation = angle(box, pointer);\n\n  */\n\n  angle(s1, s2) {\n    return Math.atan2(\n      //This is the code you need if you don't want to compensate\n      //for a possible shift in the sprites' x/y anchor points\n      /*\n      (s2.y + s2.height / 2) - (s1.y + s1.height / 2),\n      (s2.x + s2.width / 2) - (s1.x + s1.width / 2)\n      */\n      //This code adapts to a shifted anchor point\n      (s2.y + this._getCenter(s2, s2.height, \"y\")) - (s1.y + this._getCenter(s1, s1.height, \"y\")),\n      (s2.x + this._getCenter(s2, s2.width, \"x\")) - (s1.x + this._getCenter(s1, s1.width, \"x\"))\n    );\n  }\n\n  /*\n  _getCenter\n  ----------\n\n  A utility that finds the center point of the sprite. If it's anchor point is the\n  sprite's top left corner, then the center is calculated from that point.\n  If the anchor point has been shifted, then the anchor x/y point is used as the sprite's center\n  */\n\n  _getCenter(o, dimension, axis) {\n    if (o.anchor !== undefined) {\n      if (o.anchor[axis] !== 0) {\n        return 0;\n      } else {\n        //console.log(o.anchor[axis])\n        return dimension / 2;\n      }\n    } else {\n      return dimension; \n    }\n  }\n  \n\n  /*\n  rotateAroundSprite\n  ------------\n  Make a sprite rotate around another sprite.\n  Parameters:\n  a. The sprite you want to rotate.\n  b. The sprite around which you want to rotate the first sprite.\n  c. The distance, in pixels, that the roating sprite should be offset from the center.\n  d. The angle of rotations, in radians.\n\n     gu.rotateAroundSprite(orbitingSprite, centerSprite, 50, angleInRadians);\n\n  Use it inside a game loop, and make sure you update the angle value (the 4th argument) each frame.\n  */\n\n  rotateAroundSprite(rotatingSprite, centerSprite, distance, angle) {\n    rotatingSprite.x\n      = (centerSprite.x + this._getCenter(centerSprite, centerSprite.width, \"x\")) - rotatingSprite.parent.x\n      + (distance * Math.cos(angle))\n      - this._getCenter(rotatingSprite, rotatingSprite.width, \"x\");\n\n    rotatingSprite.y\n      = (centerSprite.y + this._getCenter(centerSprite, centerSprite.height, \"y\")) - rotatingSprite.parent.y\n      + (distance * Math.sin(angle))\n      - this._getCenter(rotatingSprite, rotatingSprite.height, \"y\");\n  }\n\n  /*\n  rotateAroundPoint\n  -----------------\n  Make a point rotate around another point.\n  Parameters:\n  a. The point you want to rotate.\n  b. The point around which you want to rotate the first point.\n  c. The distance, in pixels, that the roating sprite should be offset from the center.\n  d. The angle of rotations, in radians.\n\n     gu.rotateAroundPoint(orbitingPoint, centerPoint, 50, angleInRadians);\n\n  Use it inside a game loop, and make sure you update the angle value (the 4th argument) each frame.\n\n  */\n\n  rotateAroundPoint(pointX, pointY, distanceX, distanceY, angle) {\n    let point = {};\n    point.x = pointX + Math.cos(angle) * distanceX;\n    point.y = pointY + Math.sin(angle) * distanceY;\n    return point;\n  }\n\n\n  /*\n  randomInt\n  ---------\n\n  Return a random integer between a minimum and maximum value\n  Parameters: \n  a. An integer.\n  b. An integer.\n  Here's how you can use it to get a random number between, 1 and 10:\n\n     let number = gu.randomInt(1, 10);\n\n  */\n\n  randomInt(min, max) {\n    return Math.floor(Math.random() * (max - min + 1)) + min;\n  }\n\n  /*\n  randomFloat\n  -----------\n\n  Return a random floating point number between a minimum and maximum value\n  Parameters: \n  a. Any number.\n  b. Any number.\n  Here's how you can use it to get a random floating point number between, 1 and 10:\n\n      let number = gu.randomFloat(1, 10);\n\n  */\n\n  randomFloat(min, max) {\n    return min + Math.random() * (max - min);\n  }\n\n  /*\n  Wait\n  ----\n\n  Lets you wait for a specific number of milliseconds before running the\n  next function. \n   \n    wait(1000, runThisFunctionNext());\n  \n  */\n\n  wait(duration, callBack) {\n    setTimeout(callBack, duration);\n  }\n\n  /*\n  Move\n  ----\n\n  Move a sprite by adding it's velocity to it's position. The sprite \n  must have `vx` and `vy` values for this to work. You can supply a\n  single sprite, or a list of sprites, separated by commas.\n\n      move(sprite);\n  */\n\n  move(...sprites) {\n\n    //Move sprites that's aren't in an array\n    if (!(sprites[0] instanceof Array)) {\n      if (sprites.length > 1) {\n        sprites.forEach(sprite  => {\n          sprite.x += sprite.vx;\n          sprite.y += sprite.vy;\n        });\n      } else {\n        sprites[0].x += sprites[0].vx;\n        sprites[0].y += sprites[0].vy;\n      }\n    }\n\n    //Move sprites in an array of sprites\n    else {\n      let spritesArray = sprites[0];\n      if (spritesArray.length > 0) {\n        for (let i = spritesArray.length - 1; i >= 0; i--) {\n          let sprite = spritesArray[i];\n          sprite.x += sprite.vx;\n          sprite.y += sprite.vy;\n        }\n      }\n    }\n  }\n\n\n  /*\n  World camera\n  ------------\n\n  The `worldCamera` method returns a `camera` object\n  with `x` and `y` properties. It has\n  two useful methods: `centerOver`, to center the camera over\n  a sprite, and `follow` to make it follow a sprite.\n  `worldCamera` arguments: worldObject, theCanvas\n  The worldObject needs to have a `width` and `height` property.\n  */\n\n  worldCamera(world, worldWidth, worldHeight, canvas) {\n\n    //Define a `camera` object with helpful properties\n    let camera = {\n      width: canvas.width,\n      height: canvas.height,\n      _x: 0,\n      _y: 0,\n\n      //`x` and `y` getters/setters\n      //When you change the camera's position,\n      //they shift the position of the world in the opposite direction\n      get x() {\n        return this._x;\n      },\n      set x(value) {\n        this._x = value;\n        world.x = -this._x;\n        //world._previousX = world.x;\n      },\n      get y() {\n        return this._y;\n      },\n      set y(value) {\n        this._y = value;\n        world.y = -this._y;\n        //world._previousY = world.y;\n      },\n\n      //The center x and y position of the camera\n      get centerX() {\n        return this.x + (this.width / 2);\n      },\n      get centerY() {\n        return this.y + (this.height / 2);\n      },\n\n      //Boundary properties that define a rectangular area, half the size\n      //of the game screen. If the sprite that the camera is following\n      //is inide this area, the camera won't scroll. If the sprite\n      //crosses this boundary, the `follow` function ahead will change\n      //the camera's x and y position to scroll the game world\n      get rightInnerBoundary() {\n        return this.x + (this.width / 2) + (this.width / 4);\n      },\n      get leftInnerBoundary() {\n        return this.x + (this.width / 2) - (this.width / 4);\n      },\n      get topInnerBoundary() {\n        return this.y + (this.height / 2) - (this.height / 4);\n      },\n      get bottomInnerBoundary() {\n        return this.y + (this.height / 2) + (this.height / 4);\n      },\n\n      //The code next defines two camera \n      //methods: `follow` and `centerOver`\n\n      //Use the `follow` method to make the camera follow a sprite\n      follow: function(sprite) {\n\n        //Check the sprites position in relation to the inner\n        //boundary. Move the camera to follow the sprite if the sprite \n        //strays outside the boundary\n        if(sprite.x < this.leftInnerBoundary) {\n          this.x = sprite.x - (this.width / 4);\n        }\n        if(sprite.y < this.topInnerBoundary) {\n          this.y = sprite.y - (this.height / 4);\n        }\n        if(sprite.x + sprite.width > this.rightInnerBoundary) {\n          this.x = sprite.x + sprite.width - (this.width / 4 * 3);\n        }\n        if(sprite.y + sprite.height > this.bottomInnerBoundary) {\n          this.y = sprite.y + sprite.height - (this.height / 4 * 3);\n        }\n\n        //If the camera reaches the edge of the map, stop it from moving\n        if(this.x < 0) {\n          this.x = 0;\n        }\n        if(this.y < 0) {\n          this.y = 0;\n        }\n        if(this.x + this.width > worldWidth) {\n          this.x = worldWidth - this.width;\n        }\n        if(this.y + this.height > worldHeight) {\n          this.y = worldHeight - this.height;\n        }\n      },\n\n      //Use the `centerOver` method to center the camera over a sprite\n      centerOver: function(sprite) {\n\n        //Center the camera over a sprite\n        this.x = (sprite.x + sprite.halfWidth) - (this.width / 2);\n        this.y = (sprite.y + sprite.halfHeight) - (this.height / 2);\n      }\n    };\n    \n    //Return the `camera` object \n    return camera;\n  };\n}\n"]}