{"version":3,"sources":["../src/spriteUtilities.js"],"names":[],"mappings":"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","file":"spriteUtilities.js","sourcesContent":["class SpriteUtilities{\n  constructor(renderingEngine = PIXI) {\n    if (renderingEngine === undefined) throw new Error(\"Please supply a reference to PIXI in the SpriteUtilities constructor before using spriteUtilities.js\"); \n\n    //Find out which rendering engine is being used (the default is Pixi)\n    this.renderer = \"\";\n\n    //If the `renderingEngine` is Pixi, set up Pixi object aliases\n    if (renderingEngine.ParticleContainer && renderingEngine.Sprite) {\n      this.renderer = \"pixi\";\n      this.Container = renderingEngine.Container;\n      this.ParticleContainer = renderingEngine.ParticleContainer;\n      this.TextureCache = renderingEngine.utils.TextureCache;\n      this.Texture = renderingEngine.Texture;\n      this.Rectangle = renderingEngine.Rectangle;\n      this.MovieClip = renderingEngine.extras.MovieClip;\n      this.BitmapText = renderingEngine.extras.BitmapText;\n      this.Sprite = renderingEngine.Sprite;\n      this.TilingSprite = renderingEngine.extras.TilingSprite;\n      this.Graphics = renderingEngine.Graphics;\n      this.Text = renderingEngine.Text;\n      \n      //An array to store all the shaking sprites\n      this.shakingSprites = [];\n    }\n  }\n\n  update() {\n    if (this.shakingSprites.length > 0) {\n      for(let i = this.shakingSprites.length - 1; i >= 0; i--) {\n        let shakingSprite = this.shakingSprites[i];\n        if (shakingSprite.updateShake) shakingSprite.updateShake();\n      } \n    }\n  }\n\n  sprite(source, x = 0, y = 0, tiling = false, width, height) {\n\n    let o, texture;\n\n    //Create a sprite if the `source` is a string \n    if (typeof source === \"string\") {\n\n      //Access the texture in the cache if it's there\n      if (this.TextureCache[source]) {\n        texture = this.TextureCache[source];\n      }\n\n      //If it's not is the cache, load it from the source file\n      else {\n        texture = this.Texture.fromImage(source);\n      }\n\n      //If the texture was created, make the o\n      if (texture) {\n\n        //If `tiling` is `false`, make a regular `Sprite`\n        if (!tiling) {\n          o = new this.Sprite(texture);\n        }\n\n        //If `tiling` is `true` make a `TilingSprite`\n        else {\n          o = new this.TilingSprite(texture, width, height);\n        }\n      }\n      //But if the source still can't be found, alert the user\n      else {\n        throw new Error(`${source} cannot be found`);\n      }\n    }\n\n    //Create a o if the `source` is a texture\n    else if (source instanceof this.Texture) {\n      if (!tiling) {\n        o = new this.Sprite(source);\n      } else {\n        o = new this.TilingSprite(source, width, height);\n      }\n    }\n\n    //Create a `MovieClip` o if the `source` is an array\n    else if (source instanceof Array) {\n\n      //Is it an array of frame ids or textures?\n      if (typeof source[0] === \"string\") {\n\n        //They're strings, but are they pre-existing texture or\n        //paths to image files?\n        //Check to see if the first element matches a texture in the\n        //cache\n        if (this.TextureCache[source[0]]) {\n\n          //It does, so it's an array of frame ids\n          o = this.MovieClip.fromFrames(source);\n        } else {\n\n          //It's not already in the cache, so let's load it\n          o = this.MovieClip.fromImages(source);\n        }\n      }\n\n      //If the `source` isn't an array of strings, check whether\n      //it's an array of textures\n      else if (source[0] instanceof this.Texture) {\n\n        //Yes, it's an array of textures. \n        //Use them to make a MovieClip o \n        o = new this.MovieClip(source);\n      }\n    }\n\n    //If the sprite was successfully created, intialize it\n    if (o) {\n\n      //Position the sprite\n      o.x = x;\n      o.y = y;\n\n      //Set optional width and height\n      if (width) o.width = width;\n      if (height) o.height = height;\n\n      //If the sprite is a MovieClip, add a state player so that\n      //it's easier to control\n      if (o instanceof this.MovieClip) this.addStatePlayer(o);\n\n      //Assign the sprite\n      return o;\n    }\n  }\n\n  addStatePlayer(sprite) {\n\n    let frameCounter = 0,\n      numberOfFrames = 0,\n      startFrame = 0,\n      endFrame = 0,\n      timerInterval = undefined;\n\n    //The `show` function (to display static states)\n    function show(frameNumber) {\n\n      //Reset any possible previous animations\n      reset();\n\n      //Find the new state on the sprite\n      sprite.gotoAndStop(frameNumber);\n    }\n\n    //The `stop` function stops the animation at the current frame\n    function stopAnimation() {\n      reset();\n      sprite.gotoAndStop(sprite.currentFrame);\n    }\n\n    //The `playSequence` function, to play a sequence of frames\n    function playAnimation(sequenceArray) {\n\n      //Reset any possible previous animations\n      reset();\n\n      //Figure out how many frames there are in the range\n      if (!sequenceArray) {\n        startFrame = 0;\n        endFrame = sprite.totalFrames - 1;\n      } else {\n        startFrame = sequenceArray[0];\n        endFrame = sequenceArray[1];\n      }\n\n      //Calculate the number of frames\n      numberOfFrames = endFrame - startFrame;\n\n      //Compensate for two edge cases:\n      //1. If the `startFrame` happens to be `0`\n      /*\n      if (startFrame === 0) {\n        numberOfFrames += 1;\n        frameCounter += 1;\n      }\n      */\n\n      //2. If only a two-frame sequence was provided\n      /*\n      if(numberOfFrames === 1) {\n        numberOfFrames = 2;\n        frameCounter += 1;\n      }  \n      */\n\n      //Calculate the frame rate. Set the default fps to 12\n      if (!sprite.fps) sprite.fps = 12;\n      let frameRate = 1000 / sprite.fps;\n\n      //Set the sprite to the starting frame\n      sprite.gotoAndStop(startFrame);\n\n      //Set the `frameCounter` to the first frame \n      frameCounter = 1;\n\n      //If the state isn't already `playing`, start it\n      if (!sprite.animating) {\n        timerInterval = setInterval(advanceFrame.bind(this), frameRate);\n        sprite.animating = true;\n      }\n    }\n\n    //`advanceFrame` is called by `setInterval` to display the next frame \n    //in the sequence based on the `frameRate`. When the frame sequence \n    //reaches the end, it will either stop or loop\n    function advanceFrame() {\n\n      //Advance the frame if `frameCounter` is less than \n      //the state's total frames\n      if (frameCounter < numberOfFrames + 1) {\n\n        //Advance the frame\n        sprite.gotoAndStop(sprite.currentFrame + 1);\n\n        //Update the frame counter\n        frameCounter += 1;\n\n        //If we've reached the last frame and `loop`\n        //is `true`, then start from the first frame again\n      } else {\n        if (sprite.loop) {\n          sprite.gotoAndStop(startFrame);\n          frameCounter = 1;\n        }\n      }\n    }\n\n    function reset() {\n\n      //Reset `sprite.playing` to `false`, set the `frameCounter` to 0, //and clear the `timerInterval`\n      if (timerInterval !== undefined && sprite.animating === true) {\n        sprite.animating = false;\n        frameCounter = 0;\n        startFrame = 0;\n        endFrame = 0;\n        numberOfFrames = 0;\n        clearInterval(timerInterval);\n      }\n    }\n\n    //Add the `show`, `play`, `stop`, and `playSequence` methods to the sprite\n    sprite.show = show;\n    sprite.stopAnimation = stopAnimation;\n    sprite.playAnimation = playAnimation;\n  }\n\n  //`tilingSpirte` lets you quickly create Pixi tiling sprites\n  tilingSprite(source, width, height, x, y) {\n    if (width === undefined) {\n      throw new Error(\"Please define a width as your second argument for the tiling sprite\");\n    }\n    if (height === undefined) {\n      throw new Error(\"Please define a height as your third argument for the tiling sprite\");\n    }\n    let o = this.sprite(source, x, y, true, width, height);\n\n    //Add `tileX`, `tileY`, `tileScaleX` and `tileScaleY` properties\n    Object.defineProperties(o, {\n      \"tileX\": {\n        get() {\n          return o.tilePosition.x;\n        },\n        set(value) {\n          o.tilePosition.x = value;\n        }, \n        enumerable: true, configurable: true\n      },\n      \"tileY\": {\n        get() {\n          return o.tilePosition.y;\n        },\n        set(value) {\n          o.tilePosition.y = value;\n        }, \n        enumerable: true, configurable: true\n      },\n      \"tileScaleX\": {\n        get() {\n          return o.tileScale.x;\n        },\n        set(value) {\n          o.tileScale.x = value;\n        }, \n        enumerable: true, configurable: true\n      },\n      \"tileScaleY\": {\n        get() {\n          return o.tileScale.y;\n        },\n        set(value) {\n          o.tileScale.y = value;\n        }, \n        enumerable: true, configurable: true\n      },\n    });\n    \n    return o\n  }\n\n  filmstrip(\n    texture,\n    frameWidth,\n    frameHeight,\n    spacing = 0\n  ) {\n\n    //An array to store the x/y positions of the frames\n    let positions = [];\n\n    //Find the width and height of the texture\n    let textureWidth = this.TextureCache[texture].width,\n      textureHeight = this.TextureCache[texture].height;\n\n    //Find out how many columns and rows there are\n    let columns = textureWidth / frameWidth,\n      rows = textureHeight / frameHeight;\n\n    //Find the total number of frames\n    let numberOfFrames = columns * rows;\n\n    for (let i = 0; i < numberOfFrames; i++) {\n\n      //Find the correct row and column for each frame\n      //and figure out its x and y position\n      let x = (i % columns) * frameWidth,\n        y = Math.floor(i / columns) * frameHeight;\n\n      //Compensate for any optional spacing (padding) around the tiles if\n      //there is any. This bit of code accumlates the spacing offsets from the \n      //left side of the tileset and adds them to the current tile's position \n      if (spacing > 0) {\n        x += spacing + (spacing * i % columns);\n        y += spacing + (spacing * Math.floor(i / columns));\n      }\n\n      //Add the x and y value of each frame to the `positions` array\n      positions.push([x, y]);\n    }\n\n    //Return the frames\n    return this.frames(texture, positions, frameWidth, frameHeight);\n  }\n\n  //Make a texture from a frame in another texture or image\n  frame(source, x, y, width, height) {\n\n    let texture, imageFrame;\n\n    //If the source is a string, it's either a texture in the\n    //cache or an image file\n    if (typeof source === \"string\") {\n      if (this.TextureCache[source]) {\n        texture = new this.Texture(this.TextureCache[source]);\n      }\n    }\n\n    //If the `source` is a texture,  use it\n    else if (source instanceof this.Texture) {\n      texture = new this.Texture(source);\n    }\n    if (!texture) {\n      throw new Error(`Please load the ${source} texture into the cache.`);\n    } else {\n\n      //Make a rectangle the size of the sub-image\n      imageFrame = new this.Rectangle(x, y, width, height);\n      texture.frame = imageFrame;\n      return texture;\n    }\n  }\n\n  //Make an array of textures from a 2D array of frame x and y coordinates in\n  //texture\n  frames(source, coordinates, frameWidth, frameHeight) {\n\n    let baseTexture, textures;\n\n    //If the source is a string, it's either a texture in the\n    //cache or an image file\n    if (typeof source === \"string\") {\n      if (this.TextureCache[source]) {\n        baseTexture = new this.Texture(this.TextureCache[source]);\n      }\n    }\n    //If the `source` is a texture,  use it\n    else if (source instanceof this.Texture) {\n      baseTexture = new this.Texture(source);\n    }\n    if (!baseTexture) {\n      throw new Error(`Please load the ${source} texture into the cache.`);\n    } else {\n      let textures = coordinates.map((position) => {\n        let x = position[0],\n          y = position[1];\n        let imageFrame = new this.Rectangle(x, y, frameWidth, frameHeight);\n        let frameTexture = new this.Texture(baseTexture);\n        frameTexture.frame = imageFrame;\n        return frameTexture\n      });\n      return textures;\n    }\n  }\n\n  frameSeries(startNumber = 0, endNumber = 1, baseName = \"\", extension = \"\") {\n\n    //Create an array to store the frame names\n    let frames = [];\n\n    for (let i = startNumber; i < endNumber + 1; i++) {\n      let frame = this.TextureCache[`${baseName + i + extension}`];\n      frames.push(frame);\n    }\n    return frames;\n  }\n\n  /* Text creation */\n\n  //The`text` method is a quick way to create a Pixi Text sprite\n  text(content = \"message\", font = \"16px sans\", fillStyle = \"red\", x = 0, y = 0) {\n\n    //Create a Pixi Sprite object\n    let message = new this.Text(content, {font: font, fill: fillStyle});\n    message.x = x;\n    message.y = y;\n\n    //Add a `_text` property with a getter/setter\n    message._content = content;\n    Object.defineProperty(message, \"content\", {\n      get() {\n        return this._content;\n      },\n      set(value) {\n        this._content = value;\n        this.text = value;\n      },\n      enumerable: true, configurable: true\n    });\n\n    //Return the text object\n    return message;\n  }\n\n  //The`bitmapText` method lets you create bitmap text\n  bitmapText(content = \"message\", font, align, tint, x = 0, y = 0) {\n\n    //Create a Pixi Sprite object\n    let message = new this.BitmapText(content, {font: font, align: align, tint: tint});\n    message.x = x;\n    message.y = y;\n\n    //Add a `_text` property with a getter/setter\n    message._content = content;\n    Object.defineProperty(message, \"content\", {\n      get() {\n        return this._content;\n      },\n      set(value) {\n        this._content = value;\n        this.text = value;\n      },\n      enumerable: true, configurable: true\n    });\n\n    //Return the text object\n    return message;\n  }\n\n  /* Shapes and lines */\n\n  //Rectangle\n  rectangle(\n      width = 32, \n      height = 32,  \n      fillStyle = 0xFF3300, \n      strokeStyle = 0x0033CC, \n      lineWidth = 0,\n      x = 0, \n      y = 0 \n    ){\n\n    let o = new this.Graphics();\n    o._sprite = undefined;\n    o._width = width;\n    o._height = height;\n    o._fillStyle = this.color(fillStyle);\n    o._strokeStyle = this.color(strokeStyle);\n    o._lineWidth = lineWidth;\n\n    //Draw the rectangle\n    let draw = (width, height, fillStyle, strokeStyle, lineWidth) => {\n      o.clear();\n      o.beginFill(fillStyle);\n      if (lineWidth > 0) {\n        o.lineStyle(lineWidth, strokeStyle, 1);\n      }\n      o.drawRect(0, 0, width, height);\n      o.endFill();\n    };\n\n    //Draw the line and capture the sprite that the `draw` function\n    //returns\n    draw(o._width, o._height, o._fillStyle, o._strokeStyle, o._lineWidth);\n\n    //Generate a texture from the rectangle\n    let texture = o.generateTexture();\n\n    //Use the texture to create a sprite\n    let sprite = new this.Sprite(texture);\n\n    //Position the sprite\n    sprite.x = x;\n    sprite.y = y;\n\n    //Add getters and setters to the sprite\n    let self = this;\n    Object.defineProperties(sprite, {\n      \"fillStyle\": {\n        get() {\n          return o._fillStyle;\n        },\n        set(value) {\n          o._fillStyle = self.color(value);\n\n          //Draw the new rectangle \n          draw(o._width, o._height, o._fillStyle, o._strokeStyle, o._lineWidth, o._x, o._y);\n\n          //Generate a new texture and set it as the sprite's texture\n          let texture = o.generateTexture();\n          o._sprite.texture = texture;\n        }, \n        enumerable: true, configurable: true\n      },\n      \"strokeStyle\": {\n        get() {\n          return o._strokeStyle;\n        },\n        set(value) {\n          o._strokeStyle = self.color(value);\n\n          //Draw the new rectangle \n          draw(o._width, o._height, o._fillStyle, o._strokeStyle, o._lineWidth, o._x, o._y);\n\n          //Generate a new texture and set it as the sprite's texture\n          let texture = o.generateTexture();\n          o._sprite.texture = texture;\n        }, \n        enumerable: true, configurable: true\n      },\n      \"lineWidth\": {\n        get() {\n          return o._lineWidth;\n        },\n        set(value) {\n          o._lineWidth = value;\n\n          //Draw the new rectangle \n          draw(o._width, o._height, o._fillStyle, o._strokeStyle, o._lineWidth, o._x, o._y);\n\n          //Generate a new texture and set it as the sprite's texture\n          let texture = o.generateTexture();\n          o._sprite.texture = texture;\n        }, \n        enumerable: true, configurable: true\n      }\n    });\n    \n    //Get a local reference to the sprite so that we can \n    //change the rectangle properties later using the getters/setters\n    o._sprite = sprite;\n\n    //Return the sprite\n    return sprite;\n  }\n\n  //Circle\n  circle(\n      diameter = 32, \n      fillStyle = 0xFF3300, \n      strokeStyle = 0x0033CC, \n      lineWidth = 0,\n      x = 0, \n      y = 0 \n    ){\n\n    let o = new this.Graphics();\n    o._diameter = diameter;\n    o._fillStyle = this.color(fillStyle);\n    o._strokeStyle = this.color(strokeStyle);\n    o._lineWidth = lineWidth;\n\n    //Draw the circle\n    let draw = (diameter, fillStyle, strokeStyle, lineWidth) => {\n      o.clear(); \n      o.beginFill(fillStyle);\n      if (lineWidth > 0) {\n        o.lineStyle(lineWidth, strokeStyle, 1);\n      }\n      o.drawCircle(0, 0, diameter / 2);\n      o.endFill();\n    };\n\n    //Draw the cirlce\n    draw(o._diameter, o._fillStyle, o._strokeStyle, o._lineWidth);\n\n    //Generate a texture from the rectangle\n    let texture = o.generateTexture();\n\n    //Use the texture to create a sprite\n    let sprite = new this.Sprite(texture);\n\n    //Position the sprite\n    sprite.x = x;\n    sprite.y = y;\n\n    //Add getters and setters to the sprite\n    let self = this;\n    Object.defineProperties(sprite, {\n      \"fillStyle\": {\n        get() {\n          return o._fillStyle;\n        },\n        set(value) {\n          o._fillStyle = self.color(value);\n\n          //Draw the cirlce\n          draw(o._diameter, o._fillStyle, o._strokeStyle, o._lineWidth);\n\n          //Generate a new texture and set it as the sprite's texture\n          let texture = o.generateTexture();\n          o._sprite.texture = texture;\n        }, \n        enumerable: true, configurable: true\n      },\n      \"strokeStyle\": {\n        get() {\n          return o._strokeStyle;\n        },\n        set(value) {\n          o._strokeStyle = self.color(value);\n\n          //Draw the cirlce\n          draw(o._diameter, o._fillStyle, o._strokeStyle, o._lineWidth);\n\n          //Generate a new texture and set it as the sprite's texture\n          let texture = o.generateTexture();\n          o._sprite.texture = texture;\n        }, \n        enumerable: true, configurable: true\n      },\n      \"diameter\": {\n        get() {\n          return o._diameter;\n        },\n        set(value) {\n          o._lineWidth = 10;\n\n          //Draw the cirlce\n          draw(o._diameter, o._fillStyle, o._strokeStyle, o._lineWidth);\n\n          //Generate a new texture and set it as the sprite's texture\n          let texture = o.generateTexture();\n          o._sprite.texture = texture;\n        }, \n        enumerable: true, configurable: true\n      },\n      \"radius\": {\n        get() {\n          return o._diameter / 2;\n        },\n        set(value) {\n\n          //Draw the cirlce\n          draw(value * 2, o._fillStyle, o._strokeStyle, o._lineWidth);\n\n          //Generate a new texture and set it as the sprite's texture\n          let texture = o.generateTexture();\n          o._sprite.texture = texture;\n        }, \n        enumerable: true, configurable: true\n      },\n    });\n    //Get a local reference to the sprite so that we can \n    //change the circle properties later using the getters/setters\n    o._sprite = sprite;\n\n    //Return the sprite\n    return sprite;\n  }\n\n  //Line\n  line(\n      strokeStyle = 0x000000, \n      lineWidth = 1, \n      ax = 0, \n      ay = 0, \n      bx = 32, \n      by = 32\n    ){\n\n    //Create the line object\n    let o = new this.Graphics();\n\n    //Private properties\n    o._strokeStyle = this.color(strokeStyle);\n    o._width = lineWidth;\n    o._ax = ax;\n    o._ay = ay;\n    o._bx = bx;\n    o._by = by;\n\n    //A helper function that draws the line\n    let draw = (strokeStyle, lineWidth, ax, ay, bx, by) => {\n      o.clear();\n      o.lineStyle(lineWidth, strokeStyle, 1);\n      o.moveTo(ax, ay);\n      o.lineTo(bx, by);\n    };\n    \n    //Draw the line\n    draw(o._strokeStyle, o._width, o._ax, o._ay, o._bx, o._by);\n\n    //Define getters and setters that redefine the line's start and \n    //end points and re-draws it if they change\n    let self = this;\n    Object.defineProperties(o, {\n      \"ax\": {\n        get() {\n          return o._ax;\n        },\n        set(value) {\n          o._ax = value;\n          draw(o._strokeStyle, o._width, o._ax, o._ay, o._bx, o._by);\n        }, \n        enumerable: true, configurable: true\n      },\n      \"ay\": {\n        get() {\n          return o._ay;\n        },\n        set(value) {\n          o._ay = value;\n          draw(o._strokeStyle, o._width, o._ax, o._ay, o._bx, o._by);\n        }, \n        enumerable: true, configurable: true\n      },\n      \"bx\": {\n        get() {\n          return o._bx;\n        },\n        set(value) {\n          o._bx = value;\n          draw(o._strokeStyle, o._width, o._ax, o._ay, o._bx, o._by);\n        }, \n        enumerable: true, configurable: true\n      },\n      \"by\": {\n        get() {\n          return o._by;\n        },\n        set(value) {\n          o._by = value;\n          draw(o._strokeStyle, o._width, o._ax, o._ay, o._bx, o._by);\n        }, \n        enumerable: true, configurable: true\n      },\n      \"strokeStyle\": {\n        get() {\n          return o._strokeStyle;\n        },\n        set(value) {\n          o._strokeStyle = self.color(value);\n\n          //Draw the line\n          draw(o._strokeStyle, o._width, o._ax, o._ay, o._bx, o._by);\n        }, \n        enumerable: true, configurable: true\n      },\n      \"width\": {\n        get() {\n          return o._width;\n        },\n        set(value) {\n          o._width = value;\n\n          //Draw the line\n          draw(o._strokeStyle, o._width, o._ax, o._ay, o._bx, o._by);\n        }, \n        enumerable: true, configurable: true\n      }\n    });\n\n    //Return the line\n    return o;\n  }\n\n  /* Compound sprites */\n\n  //Use `grid` to create a grid of sprites\n  grid(\n    columns = 0, rows = 0, cellWidth = 32, cellHeight = 32,\n    centerCell = false, xOffset = 0, yOffset = 0,\n    makeSprite = undefined,\n    extra = undefined\n  ){\n\n    //Create an empty group called `container`. This `container`\n    //group is what the function returns back to the main program.\n    //All the sprites in the grid cells will be added\n    //as children to this container\n    let container = new this.Container();\n\n    //The `create` method plots the grid\n\n    let createGrid = () => {\n\n      //Figure out the number of cells in the grid\n      let length = columns * rows;\n\n      //Create a sprite for each cell\n      for(let i = 0; i < length; i++) {\n\n        //Figure out the sprite's x/y placement in the grid\n        let x = (i % columns) * cellWidth,\n            y = Math.floor(i / columns) * cellHeight;\n\n        //Use the `makeSprite` function supplied in the constructor\n        //to make a sprite for the grid cell\n        let sprite = makeSprite();\n\n        //Add the sprite to the `container`\n        container.addChild(sprite);\n\n        //Should the sprite be centered in the cell?\n\n        //No, it shouldn't be centered\n        if (!centerCell) {\n          sprite.x = x + xOffset;\n          sprite.y = y + yOffset;\n        }\n\n        //Yes, it should be centered\n        else {\n          sprite.x \n            = x + (cellWidth / 2) \n            - (sprite.width / 2) + xOffset;\n          sprite.y \n            = y + (cellHeight / 2) \n            - (sprite.width / 2) + yOffset;\n        }\n\n        //Run any optional extra code. This calls the\n        //`extra` function supplied by the constructor\n        if (extra) extra(sprite);\n      }\n    };\n\n    //Run the `createGrid` method\n    createGrid();\n\n    //Return the `container` group back to the main program\n    return container;\n  }\n\n  //Use `shoot` to create bullet sprites \n  shoot(\n    shooter, angle, x, y, container, bulletSpeed, bulletArray, bulletSprite\n  ) {\n\n    //Make a new sprite using the user-supplied `bulletSprite` function\n    let bullet = bulletSprite();\n\n    //Set the bullet's anchor point to its center\n    bullet.anchor.set(0.5, 0.5);\n\n    //Temporarily add the bullet to the shooter\n    //so that we can position it relative to the\n    //shooter's position\n    shooter.addChild(bullet);\n    bullet.x = x;\n    bullet.y = y;\n\n    //Find the bullet's global coordinates so that we can use\n    //them to position the bullet on the new parent container\n    let tempGx = bullet.getGlobalPosition().x,\n        tempGy = bullet.getGlobalPosition().y;\n\n    //Add the bullet to the new parent container using\n    //the new global coordinates\n    container.addChild(bullet);\n    bullet.x = tempGx;\n    bullet.y = tempGy;\n\n    //Set the bullet's velocity\n    bullet.vx = Math.cos(angle) * bulletSpeed;\n    bullet.vy = Math.sin(angle) * bulletSpeed;\n\n    //Push the bullet into the `bulletArray`\n    bulletArray.push(bullet);\n  }\n\n  /*\n  grid\n  ----\n\n  Helps you to automatically create a grid of sprites. `grid` returns a\n  `group` sprite object that contains a sprite for every cell in the\n  grid. You can define the rows and columns in the grid, whether or\n  not the sprites should be centered inside each cell, or what their offset from the\n  top left corner of each cell should be. Supply a function that\n  returns the sprite that you want to make for each cell. You can\n  supply an optional final function that runs any extra code after\n  each sprite has been created. Here's the format for creating a grid:\n\n      gridGroup = grid(\n\n        //Set the grid's properties\n        columns, rows, cellWidth, cellHeight,\n        areSpirtesCentered?, xOffset, yOffset,\n\n        //A function that returns a sprite\n        () => g.circle(16, \"blue\"),\n\n        //An optional final function that runs some extra code\n        () => console.log(\"extra!\")\n      );\n  */\n\n  grid(\n    columns = 0, rows = 0, cellWidth = 32, cellHeight = 32,\n    centerCell = false, xOffset = 0, yOffset = 0,\n    makeSprite = undefined,\n    extra = undefined\n  ){\n\n    //Create an empty group called `container`. This `container`\n    //group is what the function returns back to the main program.\n    //All the sprites in the grid cells will be added\n    //as children to this container\n    let container = this.group();\n\n    //The `create` method plots the grid\n    let createGrid = () => {\n\n      //Figure out the number of cells in the grid\n      let length = columns * rows;\n\n      //Create a sprite for each cell\n      for(let i = 0; i < length; i++) {\n\n        //Figure out the sprite's x/y placement in the grid\n        let x = (i % columns) * cellWidth,\n            y = Math.floor(i / columns) * cellHeight;\n\n        //Use the `makeSprite` function supplied in the constructor\n        //to make a sprite for the grid cell\n        let sprite = makeSprite();\n\n        //Add the sprite to the `container`\n        container.addChild(sprite);\n\n        //Should the sprite be centered in the cell?\n\n        //No, it shouldn't be centered\n        if (!centerCell) {\n          sprite.x = x + xOffset;\n          sprite.y = y + yOffset;\n        }\n\n        //Yes, it should be centered\n        else {\n          sprite.x \n            = x + (cellWidth / 2) \n            - sprite.halfWidth + xOffset;\n          sprite.y \n            = y + (cellHeight / 2) \n            - sprite.halfHeight + yOffset;\n        }\n\n        //Run any optional extra code. This calls the\n        //`extra` function supplied by the constructor\n        if (extra) extra(sprite);\n      }\n    };\n\n    //Run the `createGrid` method\n    createGrid();\n\n    //Return the `container` group back to the main program\n    return container;\n  }\n\n  /*\n  shake\n  -----\n\n  Used to create a shaking effect, like a screen shake\n  */\n\n  shake(sprite, magnitude = 16, angular = false) {\n\n    //Get a reference to this current object so that\n    //it's easy to maintain scope in the nested sub-functions\n    let self = this;\n\n    //A counter to count the number of shakes\n    let counter = 1;\n\n    //The total number of shakes (there will be 1 shake per frame)\n    let numberOfShakes = 10;\n\n    //Capture the sprite's position and angle so you can\n    //restore them after the shaking has finished\n    let startX = sprite.x,\n        startY = sprite.y,\n        startAngle = sprite.rotation;\n\n    //Divide the magnitude into 10 units so that you can \n    //reduce the amount of shake by 10 percent each frame\n    let magnitudeUnit = magnitude / numberOfShakes;\n    \n    //The `randomInt` helper function\n    let randomInt = (min, max) => {\n      return Math.floor(Math.random() * (max - min + 1)) + min;\n    };\n    \n    //Add the sprite to the `shakingSprites` array if it\n    //isn't already there\n    if(self.shakingSprites.indexOf(sprite) === -1) {\n\n      self.shakingSprites.push(sprite);\n      \n      //Add an `updateShake` method to the sprite.\n      //The `updateShake` method will be called each frame\n      //in the game loop. The shake effect type can be either\n      //up and down (x/y shaking) or angular (rotational shaking).\n      sprite.updateShake = () => {\n        if(angular) {\n          angularShake();\n        } else {\n          upAndDownShake();\n        }\n      };\n    }\n\n    //The `upAndDownShake` function\n    function upAndDownShake() {\n\n      //Shake the sprite while the `counter` is less than \n      //the `numberOfShakes`\n      if (counter < numberOfShakes) {\n\n        //Reset the sprite's position at the start of each shake\n        sprite.x = startX;\n        sprite.y = startY;\n\n        //Reduce the magnitude\n        magnitude -= magnitudeUnit;\n\n        //Randomly change the sprite's position\n        sprite.x += randomInt(-magnitude, magnitude);\n        sprite.y += randomInt(-magnitude, magnitude);\n\n        //Add 1 to the counter\n        counter += 1;\n      }\n\n      //When the shaking is finished, restore the sprite to its original \n      //position and remove it from the `shakingSprites` array\n      if (counter >= numberOfShakes) {\n        sprite.x = startX;\n        sprite.y = startY;\n        self.shakingSprites.splice(self.shakingSprites.indexOf(sprite), 1);\n      }\n    }\n    \n    //The `angularShake` function\n    //First set the initial tilt angle to the right (+1) \n    let tiltAngle = 1;\n\n    function angularShake() {\n      if (counter < numberOfShakes) {\n\n        //Reset the sprite's rotation\n        sprite.rotation = startAngle;\n\n        //Reduce the magnitude\n        magnitude -= magnitudeUnit;\n\n        //Rotate the sprite left or right, depending on the direction,\n        //by an amount in radians that matches the magnitude\n        sprite.rotation = magnitude * tiltAngle;\n        counter += 1;\n\n        //Reverse the tilt angle so that the sprite is tilted\n        //in the opposite direction for the next shake\n        tiltAngle *= -1;\n      }\n\n      //When the shaking is finished, reset the sprite's angle and\n      //remove it from the `shakingSprites` array\n      if (counter >= numberOfShakes) {\n        sprite.rotation = startAngle;\n        self.shakingSprites.splice(self.shakingSprites.indexOf(sprite), 1);\n      }\n    }\n  }\n\n  /*\n  _getCenter\n  ----------\n\n  A utility that finds the center point of the sprite. If it's anchor point is the\n  sprite's top left corner, then the center is calculated from that point.\n  If the anchor point has been shifted, then the anchor x/y point is used as the sprite's center\n  */\n\n  _getCenter(o, dimension, axis) {\n    if (o.anchor !== undefined) {\n      if (o.anchor[axis] !== 0) {\n        return 0;\n      } else {\n        return dimension / 2;\n      }\n    } else {\n      return dimension; \n    }\n  }\n  \n\n\n  /* Groups */\n\n  //Group sprites into a container\n  group(...sprites) {\n    let container = new this.Container();\n    sprites.forEach(sprite => {\n      container.addChild(sprite);\n    });\n    return container;\n  }\n\n  //Use the `batch` method to create a ParticleContainer\n  batch(size = 15000, options = {rotation: true, alpha: true, scale: true, uvs: true}) {\n    let o = new this.ParticleContainer(size, options);\n    return o;\n  }\n\n  //`remove` is a global convenience method that will\n  //remove any sprite, or an argument list of sprites, from its parent.\n  remove(...sprites) {\n\n    //Remove sprites that's aren't in an array\n    if (!(sprites[0] instanceof Array)) {\n      if (sprites.length > 1) {\n        sprites.forEach(sprite  => {\n          sprite.parent.removeChild(sprite);\n        });\n      } else {\n        sprites[0].parent.removeChild(sprites[0]);\n      }\n    }\n\n    //Remove sprites in an array of sprites\n    else {\n      let spritesArray = sprites[0];\n      if (spritesArray.length > 0) {\n        for (let i = spritesArray.length - 1; i >= 0; i--) {\n          let sprite = spritesArray[i];\n          sprite.parent.removeChild(sprite);\n          spritesArray.splice(spritesArray.indexOf(sprite), 1);\n        }\n      }\n    }\n  }\n\n  /* Color conversion */\n  //From: http://stackoverflow.com/questions/1573053/javascript-function-to-convert-color-names-to-hex-codes\n  //Utilities to convert HTML color string names to hexadecimal codes\n\n  colorToRGBA(color) {\n    // Returns the color as an array of [r, g, b, a] -- all range from 0 - 255\n    // color must be a valid canvas fillStyle. This will cover most anything\n    // you'd want to use.\n    // Examples:\n    // colorToRGBA('red')  # [255, 0, 0, 255]\n    // colorToRGBA('#f00') # [255, 0, 0, 255]\n    var cvs, ctx;\n    cvs = document.createElement('canvas');\n    cvs.height = 1;\n    cvs.width = 1;\n    ctx = cvs.getContext('2d');\n    ctx.fillStyle = color;\n    ctx.fillRect(0, 0, 1, 1);\n    let data = ctx.getImageData(0, 0, 1, 1).data; \n    return data;\n  }\n\n  byteToHex(num) {\n    // Turns a number (0-255) into a 2-character hex number (00-ff)\n    return ('0'+num.toString(16)).slice(-2);\n  }\n\n  colorToHex(color) {\n    // Convert any CSS color to a hex representation\n    // Examples:\n    // colorToHex('red')            # '#ff0000'\n    // colorToHex('rgb(255, 0, 0)') # '#ff0000'\n    var rgba, hex;\n    rgba = this.colorToRGBA(color);\n    hex = [0,1,2].map(\n      idx => this.byteToHex(rgba[idx])\n      ).join('');\n    return \"0x\" + hex;\n  }\n\n  //A function to find out if the user entered a number (a hex color\n  //code) or a string (an HTML color string)\n  color(value) {\n\n    //Check if it's a number\n    if(!isNaN(value)){\n\n      //Yes, it is a number, so just return it\n      return value;\n    }\n\n    //No it's not a number, so it must be a string    \n    else {\n\n      return this.colorToHex(value);\n      /*\n\n      //Find out what kind of color string it is.\n      //Let's first grab the first character of the string\n      let firstCharacter = value.charAt(0);\n\n      //If the first character is a \"#\" or a number, then\n      //we know it must be a RGBA color\n      if (firstCharacter === \"#\") {\n        console.log(\"first character: \" + value.charAt(0))\n      }\n      */\n    }\n    \n    /*\n    //Find out if the first character in the string is a number\n    if (!isNaN(parseInt(string.charAt(0)))) {\n      \n      //It's not, so convert it to a hex code\n      return colorToHex(string);\n      \n    //The use input a number, so it must be a hex code. Just return it\n    } else {\n    \n      return string;\n    }\n    \n  */\n\n  }\n  \n}\n\n\n\n"]}