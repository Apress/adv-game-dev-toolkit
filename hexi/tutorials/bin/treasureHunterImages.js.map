{"version":3,"sources":["../src/treasureHunterImages.js"],"names":[],"mappings":";;;;;;;AAKA,IAAI,YAAY,GAAG,CACjB,qBAAqB,EACrB,oBAAoB,EACpB,iBAAiB,EACjB,qBAAqB,EACrB,iBAAiB,EACjB,mBAAmB,CACpB;;;AAAC,AAGF,IAAI,CAAC,GAAG,IAAI,CAAC,GAAG,EAAE,GAAG,EAAE,KAAK,EAAE,YAAY,CAAC;;;;AAAC,AAI5C,CAAC,CAAC,aAAa,EAAE;;;AAAC,AAGlB,CAAC,CAAC,KAAK,EAAE;;;;AAAC,AAIV,IAAI,OAAO,YAAA;IAAE,MAAM,YAAA;IAAE,QAAQ,YAAA;IAAE,OAAO,YAAA;IAAE,MAAM,YAAA;IAAE,IAAI,YAAA;IAChD,SAAS,YAAA;IAAE,OAAO,YAAA;IAAE,SAAS,YAAA;IAAE,aAAa,YAAA;;;AAAC,AAGjD,SAAS,KAAK,GAAG;;;AAGf,QAAM,GAAG,CAAC,CAAC,KAAK,CAAC,mBAAmB,CAAC;;;AAAC,AAGtC,SAAO,GAAG,CAAC,CAAC,MAAM,CAAC,oBAAoB,CAAC;;;AAAC,AAGzC,MAAI,GAAG,CAAC,CAAC,MAAM,CAAC,iBAAiB,CAAC,CAAC;AACnC,MAAI,CAAC,CAAC,GAAG,EAAE;;;AAAC,AAGZ,QAAM,GAAG,CAAC,CAAC,MAAM,CAAC,qBAAqB,CAAC,CAAC;AACzC,QAAM,CAAC,CAAC,GAAG,EAAE,CAAC;AACd,QAAM,CAAC,CAAC,GAAG,CAAC,CAAC,MAAM,CAAC,MAAM,GAAG,CAAC,GAAG,MAAM,CAAC,SAAS;;;AAAC,AAGlD,UAAQ,GAAG,CAAC,CAAC,MAAM,CAAC,qBAAqB,CAAC;;;AAAC,AAG3C,UAAQ,CAAC,CAAC,GAAG,CAAC,CAAC,MAAM,CAAC,KAAK,GAAG,QAAQ,CAAC,KAAK,GAAG,EAAE,CAAC;AAClD,UAAQ,CAAC,CAAC,GAAG,CAAC,CAAC,MAAM,CAAC,MAAM,GAAG,CAAC,GAAG,QAAQ,CAAC,UAAU;;;;;;;;AAAC,AAQvD,UAAQ,CAAC,QAAQ,GAAG,KAAK;;;AAAC,AAG1B,WAAS,GAAG,CAAC,CAAC,KAAK,CAAC,OAAO,EAAE,IAAI,EAAE,MAAM,EAAE,QAAQ,CAAC;;;AAAC,AAGrD,MAAI,eAAe,GAAG,CAAC;MACnB,OAAO,GAAG,EAAE;MACZ,OAAO,GAAG,GAAG;MACb,KAAK,GAAG,CAAC;MACT,SAAS,GAAG,CAAC;;;AAAC,AAGlB,SAAO,GAAG,EAAE;;;AAAC,AAGb,OAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,eAAe,EAAE,CAAC,EAAE,EAAE;;;AAGxC,QAAI,KAAK,GAAG,CAAC,CAAC,MAAM,CAAC,iBAAiB,CAAC;;;;;AAAC,AAKxC,QAAI,CAAC,GAAG,OAAO,GAAG,CAAC,GAAG,OAAO;;;AAAC,AAG9B,QAAI,CAAC,GAAG,CAAC,CAAC,SAAS,CAAC,CAAC,EAAE,CAAC,CAAC,MAAM,CAAC,MAAM,GAAG,KAAK,CAAC,MAAM,CAAC;;;AAAC,AAGvD,SAAK,CAAC,CAAC,GAAG,CAAC,CAAC;AACZ,SAAK,CAAC,CAAC,GAAG,CAAC;;;;;;AAAC,AAMZ,SAAK,CAAC,EAAE,GAAG,KAAK,GAAG,SAAS;;;AAAC,AAG7B,aAAS,IAAI,CAAC,CAAC;;;AAAC,AAGhB,WAAO,CAAC,IAAI,CAAC,KAAK,CAAC;;;AAAC,AAGpB,aAAS,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC;GAC3B;;;AAAA,AAGD,MAAI,QAAQ,GAAG,CAAC,CAAC,SAAS,CAAC,GAAG,EAAE,CAAC,EAAE,OAAO,CAAC;MACvC,QAAQ,GAAG,CAAC,CAAC,SAAS,CAAC,GAAG,EAAE,CAAC,EAAE,KAAK,CAAC;;;AAAC,AAG1C,WAAS,GAAG,CAAC,CAAC,KAAK,CAAC,QAAQ,EAAE,QAAQ,CAAC;;;AAAC,AAGxC,WAAS,CAAC,KAAK,GAAG,QAAQ;;;AAAC,AAG3B,WAAS,CAAC,CAAC,GAAG,CAAC,CAAC,MAAM,CAAC,KAAK,GAAG,GAAG,CAAC;AACnC,WAAS,CAAC,CAAC,GAAG,CAAC;;;AAAC,AAGhB,WAAS,CAAC,QAAQ,CAAC,SAAS,CAAC;;;AAAC,AAG9B,SAAO,GAAG,CAAC,CAAC,IAAI,CAAC,YAAY,EAAE,aAAa,EAAE,OAAO,EAAE,EAAE,EAAE,EAAE,CAAC,CAAC;AAC/D,SAAO,CAAC,CAAC,GAAG,GAAG,CAAC;AAChB,SAAO,CAAC,CAAC,GAAG,CAAC,CAAC,MAAM,CAAC,MAAM,GAAG,CAAC,GAAG,EAAE;;;AAAC,AAGrC,eAAa,GAAG,CAAC,CAAC,KAAK,CAAC,OAAO,CAAC;;;AAAC,AAGjC,eAAa,CAAC,OAAO,GAAG,KAAK;;;;;;AAAC,AAM9B,GAAC,CAAC,YAAY,CAAC,MAAM,EAAE,CAAC,CAAC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAC,AAsD1B,GAAC,CAAC,KAAK,GAAG,IAAI,CAAC;CAChB;;;AAAA,AAGD,SAAS,IAAI,GAAG;;;AAGd,GAAC,CAAC,IAAI,CAAC,MAAM,CAAC;;;AAAC,AAGf,GAAC,CAAC,OAAO,CACP,MAAM,EACN;AACE,KAAC,EAAE,EAAE,EAAE,CAAC,EAAE,EAAE;AACZ,SAAK,EAAE,CAAC,CAAC,MAAM,CAAC,KAAK,GAAG,EAAE;AAC1B,UAAM,EAAE,CAAC,CAAC,MAAM,CAAC,MAAM,GAAG,EAAE;GAC7B,CACF;;;;;AAAC,AAKF,MAAI,SAAS,GAAG,KAAK;;;AAAC,AAGtB,SAAO,CAAC,OAAO,CAAC,UAAA,KAAK,EAAI;;;AAGvB,KAAC,CAAC,IAAI,CAAC,KAAK,CAAC;;;AAAC,AAGd,QAAI,cAAc,GAAG,CAAC,CAAC,OAAO,CAC5B,KAAK,EACL;AACE,OAAC,EAAE,EAAE,EAAE,CAAC,EAAE,EAAE;AACZ,WAAK,EAAE,CAAC,CAAC,MAAM,CAAC,KAAK,GAAG,EAAE;AAC1B,YAAM,EAAE,CAAC,CAAC,MAAM,CAAC,MAAM,GAAG,EAAE;KAC7B,CACF;;;;AAAC,AAIF,QAAI,cAAc,EAAE;AAClB,UAAI,cAAc,CAAC,GAAG,CAAC,KAAK,CAAC,IAAI,cAAc,CAAC,GAAG,CAAC,QAAQ,CAAC,EAAE;AAC7D,aAAK,CAAC,EAAE,IAAI,CAAC,CAAC,CAAC;OAChB;KACF;;;;AAAA,AAID,QAAI,CAAC,CAAC,gBAAgB,CAAC,MAAM,EAAE,KAAK,CAAC,EAAE;AACtC,eAAS,GAAG,IAAI,CAAC;KACjB;GACF,CAAC;;;AAAC,AAGH,MAAI,SAAS,EAAE;;;AAGb,UAAM,CAAC,KAAK,GAAG,GAAG;;;AAAC,AAGnB,aAAS,CAAC,KAAK,CAAC,KAAK,IAAI,CAAC,CAAC;GAC5B,MAAM;;;AAGL,UAAM,CAAC,KAAK,GAAG,CAAC,CAAC;GAClB;;;AAAA,AAGD,MAAI,CAAC,CAAC,gBAAgB,CAAC,MAAM,EAAE,QAAQ,CAAC,EAAE;;;AAGxC,YAAQ,CAAC,CAAC,GAAG,MAAM,CAAC,CAAC,GAAG,CAAC,CAAC;AAC1B,YAAQ,CAAC,CAAC,GAAG,MAAM,CAAC,CAAC,GAAG,CAAC,CAAC;;AAE1B,QAAI,CAAC,QAAQ,CAAC,QAAQ,EAAE;;;;AAItB,YAAM,CAAC,IAAI,EAAE,CAAC;AACd,cAAQ,CAAC,QAAQ,GAAG,IAAI,CAAC;KAC1B,CAAC;GACH;;;;;;AAAA,AAMD,MAAI,SAAS,CAAC,KAAK,CAAC,KAAK,GAAG,CAAC,EAAE;AAC7B,KAAC,CAAC,KAAK,GAAG,GAAG,CAAC;AACd,WAAO,CAAC,OAAO,GAAG,WAAW,CAAC;GAC/B;;;;AAAA,AAID,MAAI,CAAC,CAAC,gBAAgB,CAAC,QAAQ,EAAE,IAAI,CAAC,EAAE;AACtC,KAAC,CAAC,KAAK,GAAG,GAAG,CAAC;AACd,WAAO,CAAC,OAAO,GAAG,UAAU,CAAC;GAC9B;CACF;;AAED,SAAS,GAAG,GAAG;;;AAGb,WAAS,CAAC,OAAO,GAAG,KAAK,CAAC;AAC1B,eAAa,CAAC,OAAO,GAAG,IAAI,CAAC;CAC9B","file":"treasureHunterImages.js","sourcesContent":["/*\nLearn how to use Hexi to build a simple game prototype\n*/\n\n//An array that contains all the files you want to load\nlet thingsToLoad = [\n  \"images/explorer.png\",\n  \"images/dungeon.png\",\n  \"images/blob.png\",\n  \"images/treasure.png\",\n  \"images/door.png\",\n  \"sounds/chimes.wav\"\n];\n\n//Create a new Hexi instance, and start it\nlet g = hexi(512, 512, setup, thingsToLoad);\n\n//Set the background color and scale the canvas\n//g.backgroundColor = \"black\";\ng.scaleToWindow();\n\n//Start Hexi\ng.start();\n\n//Declare your global variables (global to this game, which means you\n//want to use them in more than one function)\nlet dungeon, player, treasure, enemies, chimes, exit,\n    healthBar, message, gameScene, gameOverScene;\n\n//The `setup` function runs once and is used to initializes your game \nfunction setup() {\n\n  //Create the `chimes` sound object\n  chimes = g.sound(\"sounds/chimes.wav\");\n\n  //The dungeon background\n  dungeon = g.sprite(\"images/dungeon.png\");\n\n  //The exit door\n  exit = g.sprite(\"images/door.png\");\n  exit.x = 32;\n\n  //The player sprite\n  player = g.sprite(\"images/explorer.png\");\n  player.x = 68;\n  player.y = g.canvas.height / 2 - player.halfWidth;\n\n  //Create the treasure\n  treasure = g.sprite(\"images/treasure.png\");\n\n  //Position it next to the left edge of the canvas\n  treasure.x = g.canvas.width - treasure.width - 40;\n  treasure.y = g.canvas.height / 2 - treasure.halfHeight;\n\n  //Alternatively, you could use Ga's built in convience method\n  //called `putCenter` to postion the sprite like this:\n  //g.stage.putCenter(treasure, 208, 0);\n\n  //Create a `pickedUp` property on the treasure to help us Figure\n  //out whether or not the treasure has been picked up by the player\n  treasure.pickedUp = false;\n\n  //Create the `gameScene` group and add the sprites\n  gameScene = g.group(dungeon, exit, player, treasure);\n\n  //Make the enemies\n  let numberOfEnemies = 6,\n      spacing = 48,\n      xOffset = 150,\n      speed = 2,\n      direction = 1;\n\n  //An array to store all the enemies    \n  enemies = [];\n\n  //Make as many enemies as there are `numberOfEnemies`\n  for (let i = 0; i < numberOfEnemies; i++) {\n\n    //Each enemy is a red rectangle\n    let enemy = g.sprite(\"images/blob.png\");\n\n    //Space each enemey horizontally according to the `spacing` value.\n    //`xOffset` determines the point from the left of the screen\n    //at which the first enemy should be added.\n    let x = spacing * i + xOffset;\n\n    //Give the enemy a random y position\n    let y = g.randomInt(0, g.canvas.height - enemy.height);\n\n    //Set the enemy's direction\n    enemy.x = x;\n    enemy.y = y;\n\n    //Set the enemy's vertical velocity. `direction` will be either `1` or\n    //`-1`. `1` means the enemy will move down and `-1` means the enemy will\n    //move up. Multiplying `direction` by `speed` determines the enemy's\n    //vertical direction\n    enemy.vy = speed * direction;\n\n    //Reverse the direction for the next enemy\n    direction *= -1;\n\n    //Push the enemy into the `enemies` array\n    enemies.push(enemy);\n\n    //Add the enemy to the `gameScene`\n    gameScene.addChild(enemy);\n  }\n\n  //Create the health bar\n  let outerBar = g.rectangle(128, 8, \"black\"),\n      innerBar = g.rectangle(128, 8, \"red\");\n\n  //Group the inner and outer bars\n  healthBar = g.group(outerBar, innerBar);\n\n  //Set the `innerBar` as a property of the `healthBar`\n  healthBar.inner = innerBar;\n\n  //Position the health bar\n  healthBar.x = g.canvas.width - 158;\n  healthBar.y = 4;\n\n  //Add the health bar to the `gameScene`\n  gameScene.addChild(healthBar);\n\n  //Add some text for the game over message\n  message = g.text(\"Game Over!\", \"64px Futura\", \"black\", 20, 20);\n  message.x = 120;\n  message.y = g.canvas.height / 2 - 64;\n\n  //Create a `gameOverScene` group and add the message sprite to it\n  gameOverScene = g.group(message);\n\n  //Make the `gameOverScene` invisible for now\n  gameOverScene.visible = false;\n\n  //Let the user control the player character using the keyboard.\n  //Hexi's `arrowControl` method lets you do this easily. Supply the\n  //sprite you want to move as the first argument, and the number of\n  //pixels per frame that it should move as the second argument\n  g.arrowControl(player, 5);\n\n  //The `arrowControl` method is great for prototyping a game\n  //but for more flexibility you can also program the arrow keys\n  //manually, like this:\n  /*\n  //Left arrow key `press` method\n  g.leftArrow.press = () => {\n    //Change the player's velocity when the key is pressed\n    player.vx = -5;\n    player.vy = 0;\n  };\n  //Left arrow key `release` method\n  g.leftArrow.release = () => {\n    //If the left arrow has been released, and the right arrow isn't down,\n    //and the player isn't moving vertically:\n    //Stop the player\n    if (!g.rightArrow.isDown && player.vy === 0) {\n      player.vx = 0;\n    }\n  };\n  g.upArrow.press = () => {\n    player.vy = -5;\n    player.vx = 0;\n  };\n  g.upArrow.release = () => {\n    if (!g.downArrow.isDown && player.vx === 0) {\n      player.vy = 0;\n    }\n  };\n  g.rightArrow.press = () => {\n    player.vx = 5;\n    player.vy = 0;\n  };\n  g.rightArrow.release = () => {\n    if (!g.leftArrow.isDown && player.vy === 0) {\n      player.vx = 0;\n    }\n  };\n  g.downArrow.press = () => {\n    player.vy = 5;\n    player.vx = 0;\n  };\n  g.downArrow.release = () => {\n    if (!g.upArrow.isDown && player.vx === 0) {\n      player.vy = 0;\n    }\n  };\n\n  //Hexi also has a built in `spaceBar` key objec that you can program\n  //in the same way, if you need to\n  */ \n\n  //set the game state to `play`\n  g.state = play;\n}\n\n//The `play` function contains all the game logic and runs in a loop\nfunction play() {\n\n  //Move the player\n  g.move(player);\n\n  //Keep the player contained inside the stage's area\n  g.contain(\n    player,\n    {\n      x: 32, y: 16,\n      width: g.canvas.width - 32,\n      height: g.canvas.height - 32\n    }\n  );\n\n  //Move the enemies and check for a collision\n\n  //Set `playerHit` to `false` before checking for a collision\n  let playerHit = false;\n\n  //Loop through all the sprites in the `enemies` array\n  enemies.forEach(enemy => {\n\n    //Move the enemy\n    g.move(enemy);\n\n    //Check the enemy's screen boundaries\n    let enemyHitsEdges = g.contain(\n      enemy,\n      {\n        x: 32, y: 16,\n        width: g.canvas.width - 32,\n        height: g.canvas.height - 32\n      }\n    );\n\n    //If the enemy hits the top or bottom of the stage, reverse\n    //its direction\n    if (enemyHitsEdges) {\n      if (enemyHitsEdges.has(\"top\") || enemyHitsEdges.has(\"bottom\")) {\n        enemy.vy *= -1;\n      }\n    }\n\n    //Test for a collision. If any of the enemies are touching\n    //the player, set `playerHit` to `true`\n    if (g.hitTestRectangle(player, enemy)) {\n     playerHit = true;\n    }\n  });\n\n  //If the player is hit...\n  if (playerHit) {\n\n    //Make the player semi-transparent\n    player.alpha = 0.5;\n\n    //Reduce the width of the health bar's inner rectangle by 1 pixel\n    healthBar.inner.width -= 1;\n  } else {\n\n    //Make the player fully opaque (non-transparent) if it hasn't been hit\n    player.alpha = 1;\n  }\n\n  //Check for a collision between the player and the treasure\n  if (g.hitTestRectangle(player, treasure)) {\n\n    //If the treasure is touching the player, center it over the player\n    treasure.x = player.x + 8;\n    treasure.y = player.y + 8;\n\n    if (!treasure.pickedUp) {\n\n      //If the treasure hasn't already been picked up,\n      //play the `chimes` sound\n      chimes.play();\n      treasure.pickedUp = true;\n    };\n  }\n\n  //Check for the end of the game\n\n  //Does the player have enough health? If the width of the `innerBar`\n  //is less than zero, end the game and display \"You lost!\"\n  if (healthBar.inner.width < 0) {\n    g.state = end;\n    message.content = \"You lost!\";\n  }\n\n  //If the player has brought the treasure to the exit,\n  //end the game and display \"You won!\"\n  if (g.hitTestRectangle(treasure, exit)) {\n    g.state = end;\n    message.content = \"You won!\";\n  }  \n}\n\nfunction end() {\n\n  //Hide the `gameScene` and display the `gameOverScene`\n  gameScene.visible = false;\n  gameOverScene.visible = true;\n}\n\n\n"]}