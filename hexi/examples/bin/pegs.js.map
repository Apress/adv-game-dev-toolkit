{"version":3,"sources":["../src/pegs.js"],"names":[],"mappings":";;;;;;;AAKA,IAAI,CAAC,GAAG,IAAI,CAAC,GAAG,EAAE,GAAG,EAAE,KAAK,CAAC;;;AAAC,AAG9B,CAAC,CAAC,eAAe,GAAG,OAAO,CAAC;AAC5B,CAAC,CAAC,aAAa,EAAE;;;AAAC,AAGlB,IAAI,IAAI,YAAA;IAAE,IAAI,YAAA;;;;AAAC,AAIf,CAAC,CAAC,KAAK,EAAE;;;AAAC,AAGV,SAAS,KAAK,GAAG;;;AAGf,MAAI,cAAc,GAAG,CAAC,CAAC,SAAS,CAAC,EAAE,EAAE,EAAE,CAAC;;;AAAC,AAGzC,MAAI,GAAG,CAAC,CAAC,MAAM,CAAC,cAAc,EAAE,KAAK,CAAC;;;AAAC,AAGvC,MAAI,CAAC,CAAC,GAAG,CAAC,CAAC,SAAS,CAAC,CAAC,EAAE,CAAC,CAAC,MAAM,CAAC,KAAK,GAAG,IAAI,CAAC,QAAQ,CAAC,CAAC;AACxD,MAAI,CAAC,CAAC,GAAG,CAAC;;;AAAC,AAGX,MAAI,CAAC,EAAE,GAAG,CAAC,CAAC,SAAS,CAAC,CAAC,EAAE,EAAE,EAAE,CAAC,CAAC;AAC/B,MAAI,CAAC,EAAE,GAAG,CAAC;;;AAAC,AAGZ,MAAI,CAAC,OAAO,GAAG,GAAG,CAAC;AACnB,MAAI,CAAC,SAAS,GAAG,CAAC,CAAC;AACnB,MAAI,CAAC,SAAS,GAAG,CAAC;;;AAAC,AAGnB,MAAI,CAAC,IAAI,GAAG,IAAI,GAAI,IAAI,CAAC,QAAQ,GAAG,EAAE,AAAC;;;;AAAC,AAIxC,MAAI,MAAM,GAAG,CACX,SAAS,EAAE,SAAS,EAAE,SAAS,EAAE,SAAS,EAAE,SAAS,CACtD;;;;;;;;;;;;;;;;;;;;;;AAAC,AA0BF,MAAI,GAAG,CAAC,CAAC,IAAI;;;AAGX,GAAC,EAAE,CAAC,EAAE,EAAE,EAAE,EAAE,EACZ,IAAI,EAAE,CAAC,EAAE,CAAC;;;AAGV,cAAM;AACJ,QAAI,GAAG,GAAG,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC,SAAS,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,MAAM,CAAC,CAAC;AAChD,OAAG,CAAC,SAAS,GAAG,MAAM,CAAC,CAAC,CAAC,SAAS,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC;AAC1C,WAAO,GAAG,CAAC;GACZ;;AAED;WAAM,OAAO,CAAC,GAAG,CAAC,QAAQ,CAAC;GAAA,CAC5B;;;AAAC,AAGF,MAAI,CAAC,WAAW,CAAC,EAAE,EAAE,EAAE,CAAC;;;AAAC,AAGzB,GAAC,CAAC,KAAK,GAAG,IAAI,CAAC;CAChB;;;AAAA,AAGD,SAAS,IAAI,GAAG;;;AAGd,MAAI,CAAC,EAAE,IAAI,IAAI,CAAC,OAAO;;;;AAAC,AAIxB,MAAI,CAAC,EAAE,IAAI,IAAI,CAAC,SAAS;;;;AAAC,AAI1B,GAAC,CAAC,IAAI,CAAC,IAAI,CAAC;;;;;AAAC,AAKb,MAAI,cAAc,GAAG,CAAC,CAAC,OAAO,CAAC,IAAI,EAAE,CAAC,CAAC,KAAK,EAAE,IAAI,CAAC;;;;AAAC,AAIpD,MAAI,cAAc,EAAE;AAClB,QAAG,cAAc,CAAC,GAAG,CAAC,QAAQ,CAAC,EAAE;AAC/B,UAAI,CAAC,SAAS,GAAG,IAAI,CAAC;KACvB,MAAM;AACL,UAAI,CAAC,SAAS,GAAG,CAAC,CAAC;KACpB;GACF;;;;;;AAAA,AAMD,GAAC,CAAC,GAAG,CAAC,IAAI,EAAE,IAAI,CAAC,QAAQ,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,CAAC;;;;;;;;;;;;;;;;;;;;AAAC,CAoB9C","file":"pegs.js","sourcesContent":["/*\nLearn how to test for a collision between a two circles\n*/\n\n//Create a new Hexi instance, and start it.\nlet g = hexi(512, 512, setup);\n\n//Set the background color and scale the canvas\ng.backgroundColor = \"black\";\ng.scaleToWindow();\n\n//Declare variables used in more than one function\nlet ball, pegs;\n\n//If you're not loading any files, start Hexi after\n//you've declared your global variables\ng.start();\n\n//The `setup` function to initialize your application\nfunction setup() {\n\n//Figure out a random diameter for the falling ball\n  let randomDiameter = g.randomInt(16, 64);\n \n  //Create the ball using the random diameter\n  ball = g.circle(randomDiameter, \"red\");\n\n  //Position the ball randomly somewhere across the top of the canvas\n  ball.x = g.randomInt(0, g.canvas.width - ball.diameter);\n  ball.y = 0;\n\n  //Set the ball's velocity\n  ball.vx = g.randomInt(-12, 12);\n  ball.vy = 0;\n\n  //Set the ball's gravity, friction and mass\n  ball.gravity = 0.6;\n  ball.frictionX = 1;\n  ball.frictionY = 0;\n\n  //Set the mass based on the ball's diameter\n  ball.mass = 0.75 + (ball.diameter / 32);\n\n  //An array of colors that will be chosen randomly for each\n  //circular peg in the grid\n  let colors = [\n    \"#FFABAB\", \"#FFDAAB\", \"#DDFFAB\", \"#ABE4FF\", \"#D9ABFF\"\n  ];\n  \n  /*\n  Create the grid of pegs using the `grid` function. `grid` returns a\n  `group` sprite object that contains a sprite for every cell in the\n  grid. You can define the rows and columns in the grid, whether or\n  not the sprites should be centered inside each cell, or what their offset from the\n  top left corner of each cell should be. Supply a function that\n  returns the sprite that you want to make for each cell. You can\n  supply an optional final function that runs any extra code after\n  each sprite has been created. Here's the format for creating a grid:\n\n      gridGroup = grid(\n\n        //Set the grid's properties\n        rows, columns, cellWidth, cellHeight, \n        areSpirtesCentered?, xOffset, yOffset,\n\n        //A function that returns a sprite\n        function() {return g.circle(16, \"blue\");},\n\n        //A optional final function that runs some extra code\n        function() {console.log(\"extra!\");}\n      );\n  */\n\n  pegs = g.grid(\n\n    //Set the grid's properties\n    5, 4, 96, 96, \n    true, 0, 0,\n\n    //A function that describes how to make each peg in the grid\n    () => {\n      let peg = g.circle(g.randomInt(16, 64), \"blue\");\n      peg.fillStyle = colors[g.randomInt(0, 4)];\n      return peg;\n    },\n    //Run any extra code after each peg is made, if you want to\n    () => console.log(\"extra!\")\n  );\n\n  //Position the grid of pegs\n  pegs.setPosition(16, 96);\n\n  //Change the state to `play`\n  g.state = play;  \n}\n\n//The `play` function will run in a loop\nfunction play() {\n\n  //Apply gravity to the ball's vertical velocity\n  ball.vy += ball.gravity;\n  \n  //Apply friction. ball.frictionX will be 0.96 if the ball is\n  //on the ground, and 1 if it's in the air\n  ball.vx *= ball.frictionX;\n\n  //Move the ball by applying the new calculated velocity\n  //to the ball's x and y position\n  g.move(ball);\n\n  //Check for a collision with the ball and the stage's boundary, and\n  //make the ball bounce by setting setting the last argument \n  //in the `contain` method to `true`\n  let stageCollision = g.contain(ball, g.stage, true);\n\n  //If the ball hit the bottom of the stage, add some so\n  //that the ball gradually rolls to a stop\n  if (stageCollision) {\n    if(stageCollision.has(\"bottom\")) {\n      ball.frictionX = 0.96;\n    } else {\n      ball.frictionX = 1;\n    }\n  }\n\n  //Check for a collision between the ball and the pegs using the\n  //universal `hit` method.\n  //arguments: circle, arrayOfCircles, reactToCollision?,\n  //bounceApart?, useGlobalPosition? \n  g.hit(ball, pegs.children, true, true, true);\n\n  //Alternatively, use a `forEach` loop and the lower-level\n  //`circleCollision` method\n \n  /* \n  pegs.children.forEach(peg => {\n    \n    //Make the ball bounce if it hits any of the pegs. Use the \n    //`circleCollision` function to check for collisions between\n    //a moving circle and a stationary circle. Set the third argument to\n    //`false` to prevent the circles from bouncing, and set the fourth\n    //argument to `false` if you want to use the circle's local x/y\n    //coordinates. (The global coordinates will be used by default)\n    //`circleCollision` arguments:\n    //movingCircle, stationaryCircle, bounce?, globalCoordinates?\n    \n    g.circleCollision(ball, peg, true, true);\n  });\n  */\n}\n\n\n"]}