{"version":3,"sources":["../src/blockRectangles.js"],"names":[],"mappings":";;;;;;;AAKA,IAAI,CAAC,GAAG,IAAI,CAAC,GAAG,EAAE,GAAG,EAAE,KAAK,CAAC;;;;AAAC,AAI9B,CAAC,CAAC,aAAa,EAAE;;;AAAC,AAGlB,IAAI,IAAI,YAAA;IAAE,GAAG,YAAA;IAAE,OAAO,YAAA;;;;AAAC,AAIvB,CAAC,CAAC,KAAK,EAAE;;;AAAC,AAGV,SAAS,KAAK,GAAG;;;AAGf,MAAI,GAAG,CAAC,CAAC,SAAS,CAAC,EAAE,EAAE,EAAE,EAAE,MAAM,CAAC,CAAC;AACnC,MAAI,CAAC,QAAQ,CAAC,GAAG,EAAE,GAAG,CAAC,CAAC;AACxB,GAAC,CAAC,KAAK,CAAC,SAAS,CAAC,IAAI,EAAE,IAAI,CAAC,SAAS,GAAG,EAAE,EAAE,IAAI,CAAC,UAAU,GAAG,EAAE,CAAC,CAAC;AACnE,MAAI,CAAC,SAAS,GAAG,IAAI;;;AAAC,AAGtB,KAAG,GAAG,CAAC,CAAC,SAAS,CAAC,EAAE,EAAE,EAAE,EAAE,KAAK,CAAC,CAAC;AACjC,KAAG,CAAC,QAAQ,CAAC,GAAG,EAAE,GAAG,CAAC,CAAC;AACvB,GAAC,CAAC,KAAK,CAAC,SAAS,CAAC,GAAG,EAAE,CAAC,GAAG,CAAC,SAAS,GAAE,EAAE,EAAE,CAAC,GAAG,CAAC,SAAS,GAAE,EAAE,CAAC,CAAC;AAC/D,KAAG,CAAC,SAAS,GAAG,IAAI;;;AAAC,AAGrB,SAAO,GAAG,CAAC,CAAC,IAAI,CACd,qBAAqB,EACrB,iBAAiB,EACjB,OAAO,EAAE,EAAE,EAAE,EAAE,CAChB;;;AAAC,AAGF,GAAC,CAAC,KAAK,GAAG,IAAI,CAAC;CAChB;;;AAAA,AAGD,SAAS,IAAI,GAAG;;;;;;;;;;;;AAYd,MAAI,SAAS,GAAG,CAAC,CAAC,GAAG,CAAC,IAAI,EAAE,GAAG,EAAE,IAAI,EAAE,KAAK,CAAC;;;;;;;;;;;;AAAC,AAY9C,MAAG,SAAS,EAAE;AACZ,WAAO,CAAC,OAAO,GAAG,gBAAgB,GAAG,SAAS,CAAC;GAChD,MAAM;AACL,WAAO,CAAC,OAAO,GAAG,qBAAqB,CAAC;GACzC;CACF","file":"blockRectangles.js","sourcesContent":["/*\nLearn how to prevent rectangles from intersecting\n*/\n\n//Create a new Hexi instance, and start it.\nlet g = hexi(256, 256, setup);\n\n//Set the background color and scale the canvas\n//g.backgroundColor = \"black\";\ng.scaleToWindow();\n\n//Declare variables used in more than one function\nlet blue, red, message;\n\n//If you're not loading any files, start Hexi after\n//you've declared your global variables\ng.start();\n\n//The `setup` function to initialize your application\nfunction setup() {\n\n  //Make a blue square\n  blue = g.rectangle(64, 64, \"blue\");\n  blue.setPivot(0.5, 0.5);\n  g.stage.putCenter(blue, blue.halfWidth + 16, blue.halfHeight + 16);\n  blue.draggable = true;\n  \n  //Make a red square\n  red = g.rectangle(64, 64, \"red\");\n  red.setPivot(0.5, 0.5);\n  g.stage.putCenter(red, -red.halfWidth -16, -red.halfWidth -16);\n  red.draggable = true;\n\n  //Add some text \n  message = g.text(\n    \"Drag the circles...\", \n    \"16px sans-serif\",\n    \"black\", 10, 10\n  );\n    \n  //Change the state to `play`\n  g.state = play;  \n}\n\n//The `play` function will run in a loop\nfunction play() {\n\n  /*\n  Use the universal `hit` method to prevent two rectangles from\n  overlapping. It returns a `collision` variable that tells you the side on which\n  the first rectangle touched the second rectangle. (The `collision`\n  variable will be `undefined` if there's no collision.). The second\n  sprite in the argument will block the movement of the first sprite.\n  The second sprite in the argument can push the first sprite.\n  //`hit` arguments:\n  //spriteOne, spriteTwo, reactToCollision?, bounceApart?\n  */\n  let collision = g.hit(blue, red, true, false);\n\n  /*\n  You can alternatively use the lower-level `rectangleCollision`\n  method\n  `rectangleCollision` arguments:\n  sprite1, sprite2, bounce?, useGlobalCoordinates?\n  (the third and fourth arguments default to `true`);\n  */\n  //let collision = g.rectangleCollision(blue, red);\n  \n  //Change the message if there's a collision between the rectangles\n  if(collision) {\n    message.content = \"Collision on: \" + collision; \n  } else {\n    message.content = \"Drag the squares...\";\n  }\n}\n\n\n"]}