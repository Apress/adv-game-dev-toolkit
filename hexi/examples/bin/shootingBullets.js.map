{"version":3,"sources":["../src/shootingBullets.js"],"names":[],"mappings":";;;;;;;;AAMA,IAAI,CAAC,GAAG,IAAI,CAAC,GAAG,EAAE,GAAG,EAAE,KAAK,CAAC;;;;AAAC,AAI9B,CAAC,CAAC,aAAa,EAAE;;;AAAC,AAGlB,IAAI,GAAG,YAAA;IAAE,MAAM,YAAA;IAAE,OAAO,YAAA;IAAE,OAAO,YAAA;;;;AAAC,AAIlC,CAAC,CAAC,KAAK,EAAE;;;AAAC,AAGV,SAAS,KAAK,GAAG;;;AAGf,KAAG,GAAG,CAAC,CAAC,SAAS,CAAC,EAAE,EAAE,EAAE,EAAE,MAAM,EAAE,OAAO,EAAE,CAAC,CAAC;;;AAAC,AAG9C,KAAG,CAAC,QAAQ,CAAC,GAAG,EAAE,GAAG,CAAC,CAAC;AACvB,GAAC,CAAC,KAAK,CAAC,SAAS,CAAC,GAAG,CAAC;;;;AAAC,AAIvB,QAAM,GAAG,CAAC,CAAC,IAAI,CAAC,KAAK,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,CAAC;;;;;AAAC,AAKvC,KAAG,CAAC,QAAQ,CAAC,MAAM,CAAC,CAAC;AACrB,QAAM,CAAC,CAAC,GAAG,CAAC,CAAC;AACb,QAAM,CAAC,CAAC,GAAG,CAAC;;;AAAC,AAGb,SAAO,GAAG,EAAE;;;;AAAC,AAIb,GAAC,CAAC,OAAO,CAAC,KAAK,GAAG,YAAM;AACtB,KAAC,CAAC,KAAK,CACL,GAAG;AACH,OAAG,CAAC,QAAQ;AACZ,MAAE;AACF,KAAC;AACD,KAAC,CAAC,KAAK;AACP,KAAC;AACD,WAAO;;;;AAIP;aAAM,CAAC,CAAC,MAAM,CAAC,CAAC,EAAE,KAAK,CAAC;KAAA,CACzB,CAAC;GACH;;;AAAC,AAGF,SAAO,GAAG,CAAC,CAAC,IAAI,CACd,uBAAuB,EACvB,iBAAiB,EACjB,OAAO,EAAE,EAAE,EAAE,EAAE,CAChB;;;AAAC,AAGF,GAAC,CAAC,KAAK,GAAG,IAAI,CAAC;CAEhB;;;AAAA,AAGD,SAAS,IAAI,GAAG;;;AAGd,KAAG,CAAC,QAAQ,GAAG,CAAC,CAAC,KAAK,CAAC,GAAG,EAAE,CAAC,CAAC,OAAO,CAAC;;;;;;;;;AAAC,AASvC,SAAO,GAAG,OAAO,CAAC,MAAM,CAAC,UAAA,MAAM,EAAI;;;AAGjC,KAAC,CAAC,IAAI,CAAC,MAAM,CAAC;;;AAAC,AAGf,QAAI,SAAS,GAAG,CAAC,CAAC,aAAa,CAAC,MAAM,EAAE,CAAC,CAAC,KAAK,CAAC;;;;;AAAC,AAKjD,QAAG,SAAS,EAAE;;;AAGZ,UAAI,aAAa,YAAA,CAAC;AAClB,UAAI,SAAS,CAAC,GAAG,CAAC,MAAM,CAAC,EAAE,aAAa,GAAG,MAAM,CAAC;AAClD,UAAI,SAAS,CAAC,GAAG,CAAC,OAAO,CAAC,EAAE,aAAa,GAAG,OAAO,CAAC;AACpD,UAAI,SAAS,CAAC,GAAG,CAAC,KAAK,CAAC,EAAE,aAAa,GAAG,KAAK,CAAC;AAChD,UAAI,SAAS,CAAC,GAAG,CAAC,QAAQ,CAAC,EAAE,aAAa,GAAG,QAAQ,CAAC;;;AAAA,AAGtD,aAAO,CAAC,OAAO,2BAAyB,aAAa,AAAE;;;AAAC,AAGxD,OAAC,CAAC,MAAM,CAAC,MAAM,CAAC;;;AAAC,AAGjB,aAAO,KAAK,CAAC;KACd;;;;AAAA,AAID,WAAO,IAAI,CAAC;GACb,CAAC,CAAC;CACJ","file":"shootingBullets.js","sourcesContent":["/*\nLearn how to use the `shoot` method to create a sprite \nthat can shoot bullets\n*/\n\n//Create a new Hexi instance, and start it.\nlet g = hexi(256, 256, setup);\n\n//Set the background color and scale the canvas\n//g.backgroundColor = \"black\";\ng.scaleToWindow();\n\n//Declare variables used in more than one function\nlet box, turret, bullets, message;\n\n//If you're not loading any files, start Hexi after\n//you've declared your global variables\ng.start();\n\n//The `setup` function to initialize your application\nfunction setup() {\n\n  //Make a square and center it in the stage\n  box = g.rectangle(32, 32, \"gray\", \"black\", 2);\n\n  //Rotating sprites look best if their pivot points are centered\n  box.setPivot(0.5, 0.5);\n  g.stage.putCenter(box);\n\n  //Make a turret by drawing a red, 4 pixel wide line that's 32 pixels\n  //long\n  turret = g.line(\"red\", 4, 0, 0, 32, 0);\n\n  //Add the line as a child of the box and place its\n  //start point at the box's center. (Because we centered the box's\n  //pivot point, its center has an x/y value of 0)\n  box.addChild(turret);\n  turret.x = 0;\n  turret.y = 0;\n\n  //Make an array to store the bullets\n  bullets = [];\n\n  //Call the `shoot` method every time the user presses\n  //the pointer\n  g.pointer.press = () => {\n    g.shoot(\n      box,           //The shooter\n      box.rotation,  //The angle at which to shoot\n      32,            //The x point on the shooter where the bullet should start\n      0,             //The y point on the shooter where the bullet should start\n      g.stage,       //The container you want to add the bullet to\n      7,             //The bullet's speed (pixels per frame)\n      bullets,       //The array used to store the bullets\n\n      //A function that returns the sprite that should\n      //be used to make each bullet\n      () => g.circle(8, \"red\")\n    );\n  };\n\n  //Add some text \n  message = g.text(\n    \"Click or tap to shoot\", \n    \"16px sans-serif\",\n    \"black\", 10, 10\n  );\n    \n  //Change the state to `play`\n  g.state = play;  \n\n}\n\n//The `play` function will run in a loop\nfunction play() {\n\n  //Make the box and turret angle towards the pointer\n  box.rotation = g.angle(box, g.pointer);\n\n  //Id you just want to move all the bullets without removing them\n  //they hit the screen boundaries, you can just use the help of the `move` method\n  //g.move(bullets);\n \n  //Remove the bullets if they cross the screen boundaries\n  //Loop through the bullets using `filter` so that we can remove\n  //the bullet easily\n  bullets = bullets.filter(bullet => {\n\n    //Move the bullet\n    g.move(bullet);\n\n    //Check for a collision with the stage boundary\n    let collision = g.outsideBounds(bullet, g.stage);\n\n    //If there's a collision, display the side that the collision\n    //happened on, remove the bullet sprite and filter it out of \n    //the `bullets` array\n    if(collision) {\n\n      //Find out on which side the collision happened\n      let collisionSide;\n      if (collision.has(\"left\")) collisionSide = \"left\";\n      if (collision.has(\"right\")) collisionSide = \"right\";\n      if (collision.has(\"top\")) collisionSide = \"top\";\n      if (collision.has(\"bottom\")) collisionSide = \"bottom\";\n\n      //Display the result in a text sprite\n      message.content = `The bullet hit the ${collisionSide}`; \n\n      //The `remove` function will remove a sprite for its parent.\n      g.remove(bullet); \n\n      //Remove the bullet from the `bullets` array\n      return false;\n    } \n\n    //If the bullet hasn't hit the edge of the screen,\n    //keep it in the `bullets` array\n    return true;\n  });\n}\n\n"]}