{"version":3,"sources":["../src/animationStates.js"],"names":[],"mappings":";;;;;;;AAKA,IAAI,YAAY,GAAG,CACjB,mBAAmB,EACnB,sBAAsB,CACvB;;;;;AAAC,AAKF,IAAI,CAAC,GAAG,IAAI,CAAC,GAAG,EAAE,GAAG,EAAE,KAAK,EAAE,YAAY,CAAC,CAAC;AAC5C,CAAC,CAAC,KAAK,EAAE;;;;AAAC,AAIV,CAAC,CAAC,aAAa,EAAE;;;AAAC,AAGlB,IAAI,GAAG,YAAA;IAAE,MAAM,YAAA;IAAE,SAAS,YAAA;IAAE,OAAO,YAAA;IAAE,SAAS,YAAA;IAAE,UAAU,YAAA;;;AAAC,AAG3D,SAAS,KAAK,GAAG;;;AAGf,QAAM,GAAG,CAAC,CAAC,MAAM,CAAC,mBAAmB,CAAC;;;;;;;;;;;;;AAAC,AAavC,MAAI,gBAAgB,GAAG,CAAC,CAAC,SAAS,CAAC,sBAAsB,EAAE,EAAE,EAAE,EAAE,CAAC;;;AAAC,AAGnE,KAAG,GAAG,CAAC,CAAC,MAAM,CAAC,gBAAgB,CAAC;;;;;AAAC,AAKjC,KAAG,CAAC,WAAW,CAAC,EAAE,EAAE,GAAG,CAAC;;;;;;;;;;;;;AAAC,AAezB,KAAG,CAAC,MAAM,GAAG;AACX,MAAE,EAAE,CAAC;AACL,QAAI,EAAE,CAAC;AACP,QAAI,EAAE,EAAE;AACR,SAAK,EAAE,EAAE;AACT,UAAM,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC;AACd,YAAQ,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC;AAClB,YAAQ,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC;AAClB,aAAS,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC;GACpB;;;AAAC,AAGF,KAAG,CAAC,IAAI,CAAC,GAAG,CAAC,MAAM,CAAC,KAAK,CAAC;;;AAAC,AAG3B,WAAS,GAAG,CAAC,CAAC,QAAQ,CAAC,EAAE,CAAC,CAAC;AAC3B,SAAO,GAAG,CAAC,CAAC,QAAQ,CAAC,EAAE,CAAC,CAAC;AACzB,YAAU,GAAG,CAAC,CAAC,QAAQ,CAAC,EAAE,CAAC,CAAC;AAC5B,WAAS,GAAG,CAAC,CAAC,QAAQ,CAAC,EAAE,CAAC;;;;AAAC,AAI3B,WAAS,CAAC,KAAK,GAAG,YAAM;AACtB,OAAG,CAAC,aAAa,CAAC,GAAG,CAAC,MAAM,CAAC,QAAQ,CAAC,CAAC;AACvC,OAAG,CAAC,EAAE,GAAG,CAAC,CAAC,CAAC;AACZ,OAAG,CAAC,EAAE,GAAG,CAAC,CAAC;GACZ,CAAC;AACF,WAAS,CAAC,OAAO,GAAG,YAAM;AACxB,QAAI,CAAC,UAAU,CAAC,MAAM,IAAI,GAAG,CAAC,EAAE,KAAK,CAAC,EAAE;AACtC,SAAG,CAAC,EAAE,GAAG,CAAC,CAAC;AACX,SAAG,CAAC,IAAI,CAAC,GAAG,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC;KAC3B;GACF,CAAC;AACF,SAAO,CAAC,KAAK,GAAG,YAAM;AACpB,OAAG,CAAC,aAAa,CAAC,GAAG,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC;AACrC,OAAG,CAAC,EAAE,GAAG,CAAC,CAAC,CAAC;AACZ,OAAG,CAAC,EAAE,GAAG,CAAC,CAAC;GACZ,CAAC;AACF,SAAO,CAAC,OAAO,GAAG,YAAM;AACtB,QAAI,CAAC,SAAS,CAAC,MAAM,IAAI,GAAG,CAAC,EAAE,KAAK,CAAC,EAAE;AACrC,SAAG,CAAC,EAAE,GAAG,CAAC,CAAC;AACX,SAAG,CAAC,IAAI,CAAC,GAAG,CAAC,MAAM,CAAC,EAAE,CAAC,CAAC;KACzB;GACF,CAAC;AACF,YAAU,CAAC,KAAK,GAAG,YAAM;AACvB,OAAG,CAAC,aAAa,CAAC,GAAG,CAAC,MAAM,CAAC,SAAS,CAAC,CAAC;AACxC,OAAG,CAAC,EAAE,GAAG,CAAC,CAAC;AACX,OAAG,CAAC,EAAE,GAAG,CAAC,CAAC;GACZ,CAAC;AACF,YAAU,CAAC,OAAO,GAAG,YAAM;AACzB,QAAI,CAAC,SAAS,CAAC,MAAM,IAAI,GAAG,CAAC,EAAE,KAAK,CAAC,EAAE;AACrC,SAAG,CAAC,EAAE,GAAG,CAAC,CAAC;AACX,SAAG,CAAC,IAAI,CAAC,GAAG,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;KAC5B;GACF,CAAC;AACF,WAAS,CAAC,KAAK,GAAG,YAAM;AACtB,OAAG,CAAC,aAAa,CAAC,GAAG,CAAC,MAAM,CAAC,QAAQ,CAAC,CAAC;AACvC,OAAG,CAAC,EAAE,GAAG,CAAC,CAAC;AACX,OAAG,CAAC,EAAE,GAAG,CAAC,CAAC;GACZ,CAAC;AACF,WAAS,CAAC,OAAO,GAAG,YAAM;AACxB,QAAI,CAAC,OAAO,CAAC,MAAM,IAAI,GAAG,CAAC,EAAE,KAAK,CAAC,EAAE;AACnC,SAAG,CAAC,EAAE,GAAG,CAAC,CAAC;AACX,SAAG,CAAC,IAAI,CAAC,GAAG,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC;KAC3B;GACF;;;AAAC,AAGF,GAAC,CAAC,IAAI,CAAC,4BAA4B,EAAE,aAAa,EAAE,OAAO,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC;;AAEnE,GAAC,CAAC,KAAK,GAAG,IAAI,CAAC;CAChB;;AAED,SAAS,IAAI,GAAG;;;;AAId,KAAG,CAAC,CAAC,GAAG,IAAI,CAAC,GAAG,CAAC,CAAC,EAAE,EAAE,IAAI,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC,GAAG,GAAG,CAAC,EAAE,EAAE,CAAC,CAAC,MAAM,CAAC,KAAK,GAAG,GAAG,CAAC,KAAK,GAAG,EAAE,CAAC,CAAC,CAAC;AACjF,KAAG,CAAC,CAAC,GAAG,IAAI,CAAC,GAAG,CAAC,EAAE,EAAE,IAAI,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC,GAAG,GAAG,CAAC,EAAE,EAAE,CAAC,CAAC,MAAM,CAAC,MAAM,GAAG,GAAG,CAAC,MAAM,CAAC,CAAC,CAAC;CAE9E","file":"animationStates.js","sourcesContent":["/*\nLearn how to make a complex walking game character by assigning animation\nsequences to specific sprite states.\n*/\n\nlet thingsToLoad = [\n  \"images/forest.png\",\n  \"images/walkcycle.png\"\n];\n\n//Create a new Hexi instance, and start it.\n//Load the texture atlas that inlcudes the animation frames you want\n//to load\nlet g = hexi(256, 256, setup, thingsToLoad);\ng.start();\n\n//Set the background color and scale the canvas\n//g.backgroundColor = \"black\";\ng.scaleToWindow();\n\n//Declare variables used in more than one function\nlet elf, forest, leftArrow, upArrow, downArrow, rightArrow; \n\n//The `setup` function to initialize your application\nfunction setup() {\n\n//Make the forest background\n  forest = g.sprite(\"images/forest.png\");\n\n  /*\n  If you have a complex animation made up of sequential \n  tileset frames in a single image,  you can use \n  `filmStrip` to automatically create an array of x,y\n  coordinates for each animation frame.\n  `filmStrip` arguments:\n  imageName, frameWidth, frameHeight, spacing\n  (Use the final optional `spacing` argument if there is any default\n  spacing (padding) around tileset frame images)\n  */\n\n  var walkingAnimation = g.filmstrip(\"images/walkcycle.png\", 64, 64);\n\n  //Now initialize the sprite with the film strip to create a sprite\n  elf = g.sprite(walkingAnimation);\n\n  //The sprite is now loaded up with all 36 frames of the animation\n\n  //Set the elf's x and y position\n  elf.setPosition(32, 128);\n\n  /*\n  Define the elf's animation states. These are names that correspond\n  to frames and frame sequences in the elf's animation frames. It's\n  entirely up to you to decide what you want to call these states.\n  Define animation sequences as a 2-value array:\n\n      wallkleft: [startFrame, endFrame]\n\n  The first value is the frame number that the sequence should start\n  at, and the second value is the frame number that the sequence\n  should end at.\n  */\n\n  elf.states = {\n    up: 0,\n    left: 9,\n    down: 18,\n    right: 27,\n    walkUp: [0, 8],\n    walkLeft: [10, 17],\n    walkDown: [19, 26],\n    walkRight: [28, 35]\n  };\n\n  //Use the `show` method to display the elf's `right` state\n  elf.show(elf.states.right);\n \n  //Create some keyboard objects\n  leftArrow = g.keyboard(37);\n  upArrow = g.keyboard(38);\n  rightArrow = g.keyboard(39);\n  downArrow = g.keyboard(40);\n  \n  //Assign key `press` and release methods that\n  //show and play the elf's different states\n  leftArrow.press = () => {\n    elf.playAnimation(elf.states.walkLeft);\n    elf.vx = -1;\n    elf.vy = 0;\n  };\n  leftArrow.release = () => {\n    if (!rightArrow.isDown && elf.vy === 0) {\n      elf.vx = 0;\n      elf.show(elf.states.left);\n    }\n  };\n  upArrow.press = () => {\n    elf.playAnimation(elf.states.walkUp);\n    elf.vy = -1;\n    elf.vx = 0;\n  };\n  upArrow.release = () => {\n    if (!downArrow.isDown && elf.vx === 0) {\n      elf.vy = 0;\n      elf.show(elf.states.up);\n    }\n  };\n  rightArrow.press = () => {\n    elf.playAnimation(elf.states.walkRight);\n    elf.vx = 1;\n    elf.vy = 0;\n  };\n  rightArrow.release = () => {\n    if (!leftArrow.isDown && elf.vy === 0) {\n      elf.vx = 0;\n      elf.show(elf.states.right);\n    }\n  };\n  downArrow.press = () => {\n    elf.playAnimation(elf.states.walkDown);\n    elf.vy = 1;\n    elf.vx = 0;\n  };\n  downArrow.release = () => {\n    if (!upArrow.isDown && elf.vx === 0) {\n      elf.vy = 0;\n      elf.show(elf.states.down);\n    }\n  };\n\n  //Add text instructions\n  g.text(\"Use the arrow keys to walk\", \"14px Futura\", \"white\", 6, 4);    \n\n  g.state = play;    \n}\n\nfunction play() {\n\n  //Move the elf and constrain it to the canvas boundaries\n  //(-18 and +18 are to compensate for image padding around the sprite)\n  elf.x = Math.max(-18, Math.min(elf.x + elf.vx, g.canvas.width - elf.width + 18)); \n  elf.y = Math.max(64, Math.min(elf.y + elf.vy, g.canvas.height - elf.height));\n\n}\n\n\n"]}