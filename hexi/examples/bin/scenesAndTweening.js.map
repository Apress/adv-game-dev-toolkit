{"version":3,"sources":["../src/scenesAndTweening.js"],"names":[],"mappings":";;;;;;;;;AAOA,IAAI,CAAC,GAAG,IAAI,CAAC,GAAG,EAAE,GAAG,EAAE,KAAK,EAAE,CAAC,mBAAmB,CAAC,CAAC,CAAC;AACrD,CAAC,CAAC,KAAK,EAAE;;;;AAAC,AAIV,CAAC,CAAC,aAAa,EAAE;;;AAAC,AAGlB,IAAI,QAAQ,EACR,WAAW,EACX,UAAU,EACV,QAAQ,EACR,UAAU,EACV,UAAU,EACV,QAAQ,EACR,QAAQ;;;AAAC,AAGb,SAAS,KAAK,GAAG;;;AAGf,aAAW,GAAG,CAAC,CAAC,SAAS,CAAC,GAAG,EAAE,GAAG,EAAE,OAAO,CAAC,CAAC;AAC7C,YAAU,GAAG,CAAC,CAAC,IAAI,CAAC,KAAK,EAAE,cAAc,EAAE,OAAO,CAAC;;;;AAAC,AAIpD,YAAU,CAAC,WAAW,CAAC,EAAE,EAAE,EAAE,CAAC;;;;;;;;;;;;;;;;;;AAAC,AAkB/B,UAAQ,GAAG,CAAC,CAAC,KAAK,CAAC,WAAW,EAAE,UAAU,CAAC;;;;;;;;;;;AAAC,AAW5C,YAAU,GAAG,CAAC,CAAC,SAAS,CAAC,GAAG,EAAE,GAAG,EAAE,MAAM,CAAC,CAAC;AAC3C,YAAU,GAAG,CAAC,CAAC,IAAI,CAAC,KAAK,EAAE,cAAc,EAAE,KAAK,CAAC,CAAC;AAClD,YAAU,CAAC,WAAW,CAAC,EAAE,EAAE,EAAE,CAAC;;;;AAAC,AAI/B,UAAQ,GAAG,CAAC,CAAC,KAAK,CAAC,UAAU,EAAE,UAAU,CAAC,CAAC;AAC3C,UAAQ,CAAC,CAAC,GAAG,GAAG,CAAC;AACjB,UAAQ,CAAC,CAAC,GAAG,GAAG;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAC,AA2CjB,UAAQ,GAAG,CAAC,CAAC,KAAK,CAAC,QAAQ,EAAE,GAAG,EAAE,GAAG,EAAE,EAAE,EAAE,YAAY,EAAE,IAAI,EAAE,IAAI,CAAC,CAAC;AACrE,UAAQ,GAAG,CAAC,CAAC,KAAK,CAAC,QAAQ,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,YAAY,EAAE,IAAI,EAAE,IAAI,CAAC;;;;;;;;;;AAAC,AAUjE,UAAQ,CAAC,UAAU,GAAG,YAAM;;;AAG1B,WAAO,CAAC,GAAG,CAAC,gBAAgB,CAAC;;;;;;AAAC,AAM9B,KAAC,CAAC,KAAK,CAAC,YAAY,CAAC,QAAQ,EAAE,QAAQ,CAAC,CAAC;GAC1C;;;;;;;;;;AAAC,AAUF,GAAC,CAAC,IAAI,CAAC,IAAI,EAAE,YAAM;;;;;AAKjB,KAAC,CAAC,KAAK,CAAC,QAAQ,EAAE,EAAE,EAAE,GAAG,CAAC,CAAC;GAC5B,CAAC;;;;;;;AAAC,CAOJ","file":"scenesAndTweening.js","sourcesContent":["/*\nThis is a quick introduction on how to make game scenes and\nuse Hexi's tweening effects. (For more details on how to use\ntweening effects, see the `tweening.html` example file.)\n*/\n\n//Create a new Hexi instance, and start it.\nlet g = hexi(256, 256, setup, [\"fonts/puzzler.otf\"]);\ng.start();\n\n//Set the background color and scale the canvas\n//g.backgroundColor = \"black\";\ng.scaleToWindow();\n\n//Declare variables used in more than one function\nvar sceneOne,\n    blackSquare,\n    messageOne,\n    sceneTwo,\n    blueSquare,\n    messageTwo,\n    oneTween,\n    twoTween;\n\n//The `setup` function to initialize your application\nfunction setup() {\n\n  //Make a black square and some text\n  blackSquare = g.rectangle(128, 128, \"black\");\n  messageOne = g.text(\"One\", \"16px puzzler\", \"white\");\n\n  //Use `setPosition` to set the `x` and `y` \n  //value with one line of code\n  messageOne.setPosition(40, 52);\n\n  /*\n  Create a `group` called `sceneOne` and add the\n  `blackSquare` and `messageOne` to it.\n  Groups are empty containers for sprites. You can think of them\n  as a special kind of sprite that doesn't display its own image. a\n  group's job is \n  just to display the sprites that are inside it. Groups have the\n  all same properties as ordinary sprites, so any changes that you\n  make the parent, such as its size, position or visibility, will\n  affect the child sprites that it contains. The `width` and\n  `height` of the group is determined by the size and position of\n  the sprites inside it. Whenever you use `addChild` or `removeChild` to \n  add or remove a sprite from a group, the group's `width` and `height`\n  is recalculated based on what it contains\n  */\n\n  sceneOne = g.group(blackSquare, messageOne);\n\n  //Alternatively, you could first create an empty group and \n  //use `addChild` to add the sprites, like this:\n  /*\n  sceneOne = g.group();\n  sceneOne.addChild(blackSquare);\n  sceneOne.addChild(messageOne);\n  */\n\n  //Make a blue square and some text.\n  blueSquare = g.rectangle(128, 128, \"cyan\");\n  messageTwo = g.text(\"Two\", \"16px puzzler\", \"red\");\n  messageTwo.setPosition(40, 52);\n\n  //Create a `sceneTwo` group and add `blueSquare` and\n  //`messageTwo`\n  sceneTwo = g.group(blueSquare, messageTwo);\n  sceneTwo.x = 128;\n  sceneTwo.y = 128;\n\n  //You can change the depth layers of sprites\n  //or groups or sprites using the `layer` property\n  //sceneOne.layer = 1;\n  //sceneTwo.layer = 2;\n\n  /*\n  Tweening\n  Use one of Ga's many built in tween functions to make the \n  scene groups move. Here's how to use the `slide` method to \n  make the scenes move, in a continuous loop, between the top and\n  bottom corners of the screen. There's a delay of 2000 milliseconds\n  between each repetition of the tween.\n  `slide` arguments: sprite, endX, endY, durationInFrames,\n  easingType, yoyo?, delayInMilleseconsBeforeRepeating\n  (Only the first 3 arguments are required, the rest are optional and\n  default to sensible values.)\n  The easing type (the 5th argument) can be any of the following\n  string values:\n\n    \"linear\"\n    \"smoothstep\" (the default value)\n    \"smoothstepSquared\"\n    \"smoothstepCubed\"\n    \"acceleration\"\n    \"accelertationCubed\"\n    \"deceleration\"\n    \"decelerationCubed\"\n    \"sine\"\n    \"sineSquared\"\n    \"sineCubed\"\n    \"inverseSine\"\n    \"inverseSineSquared\"\n    \"inverseSineCubed\"\n\n  Experiment by assigning different easing types and observe the\n  effect.\n    \n  If you don't what the effect to repeat in a continuous loop, just\n  set `yoyo` (the 6th argument) to `false`.\n  */\n\n  oneTween = g.slide(sceneOne, 128, 128, 60, \"smoothstep\", true, 2000); \n  twoTween = g.slide(sceneTwo, 0, 0, 60, \"smoothstep\", true, 2000); \n\n  /*\n  There are many more tween effects you can use, including `pulse`,\n  `breathe`, `fadeIn`, `fadeOut`, `scale`, `wobble`, and `strobe`.\n  (See the `tweening.html file for more examples.)\n  */\n\n  //All tween objects have a user-definable `onComplete` methods that\n  //will be called automatically when tweens are finished. \n  oneTween.onComplete = () => {\n\n    //Write a message to the console that the tween is finished\n    console.log(\"Slide finished\");\n\n    //Here's a neat effect. Use the stage's (the root container's)\n    //`swapChildren` method to swap the scene depth layers when \n    //the `slide` is finished. This makes it look like the scenes\n    //are circling above and below each other in shallow 3D space.\n    g.stage.swapChildren(sceneOne, sceneTwo);\n  };\n\n  /*\n  You can combine tween effects so that one sprite can have multiple\n  effects acting on it at any one time. Here's how you can use Ga's\n  built-in `wait` method to wait for for 5 seconds (5000 milliseconds)\n  and then run a `pulse` tween on `sceneOne`:\n  */\n\n  //Wait for 5 seconds\n  g.wait(5000, () => {\n\n    //... then use `pulse` to make a sprite fade in and out, in a\n    //continuous loop.\n    //`pulse` arguments: sprite, durationInFrames, minimumAlphaValue\n    g.pulse(sceneOne, 30, 0.3);    \n  });\n\n  /*\n  You can use `fadeIn` and `fadeOut` if you just want the fade effect\n  to happen once. Here's the format those methods use:\n  var spriteFade = g.fadeIn(sprite, durationInFrames);\n  */\n}\n\n\n"]}