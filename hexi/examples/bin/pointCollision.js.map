{"version":3,"sources":["../src/pointCollision.js"],"names":[],"mappings":";;;;;;;AAKA,IAAI,CAAC,GAAG,IAAI,CAAC,GAAG,EAAE,GAAG,EAAE,KAAK,CAAC;;;;AAAC,AAI9B,CAAC,CAAC,aAAa,EAAE;;;AAAC,AAGlB,IAAI,GAAG,YAAA;IAAE,IAAI,YAAA;IAAE,OAAO,YAAA;;;;AAAC,AAIvB,CAAC,CAAC,KAAK,EAAE;;;AAAC,AAGV,SAAS,KAAK,GAAG;;;AAGf,KAAG,GAAG,CAAC,CAAC,SAAS,CAAC,EAAE,EAAE,EAAE,EAAE,MAAM,CAAC,CAAC;AAClC,GAAC,CAAC,KAAK,CAAC,SAAS,CAAC,GAAG,EAAE,GAAG,CAAC,SAAS,GAAG,EAAE,EAAE,GAAG,CAAC,UAAU,GAAG,EAAE,CAAC;;;AAAC,AAGhE,MAAI,GAAG,CAAC,CAAC,MAAM,CAAC,EAAE,EAAE,KAAK,CAAC,CAAC;AAC3B,GAAC,CAAC,KAAK,CAAC,SAAS,CAAC,IAAI,EAAE,CAAC,IAAI,CAAC,MAAM,GAAG,EAAE,EAAE,CAAC,IAAI,CAAC,MAAM,GAAE,EAAE,CAAC;;;AAAC,AAG7D,SAAO,GAAG,CAAC,CAAC,IAAI,CACd,iBAAiB,EACjB,iBAAiB,EACjB,OAAO,EAAE,EAAE,EAAE,EAAE,CAChB;;;AAAC,AAGF,GAAC,CAAC,KAAK,GAAG,IAAI,CAAC;CAChB;;;AAAA,AAGD,SAAS,IAAI,GAAG;;;AAGd,SAAO,CAAC,OAAO,GAAG,iBAAiB;;;;;;;;;;;;AAAC,AAYpC,MAAI,YAAY,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,OAAO,EAAE,GAAG,CAAC;MACpC,aAAa,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,OAAO,EAAE,IAAI,CAAC;;;;;;;;;;;;AAAC,AAa3C,MAAG,YAAY,EAAE;AACf,WAAO,CAAC,OAAO,GAAG,MAAM,CAAC;GAC1B;;;AAAA,AAGD,MAAG,aAAa,EAAE;AAChB,WAAO,CAAC,OAAO,GAAG,OAAO,CAAC;GAC3B;CACF","file":"pointCollision.js","sourcesContent":["/*\nLearn how to test for a collision between a point and a shape \n*/\n\n//Create a new Hexi instance, and start it.\nlet g = hexi(256, 256, setup);\n\n//Set the background color and scale the canvas\n//g.backgroundColor = \"black\";\ng.scaleToWindow();\n\n//Declare variables used in more than one function\nlet box, ball, message;\n\n//If you're not loading any files, start Hexi after\n//you've declared your global variables\ng.start();\n\n//The `setup` function to initialize your application\nfunction setup() {\n\n  //Make a square\n  box = g.rectangle(64, 64, \"blue\");\n  g.stage.putCenter(box, box.halfWidth + 16, box.halfHeight + 16);\n  \n  //Make a circle\n  ball = g.circle(64, \"red\");\n  g.stage.putCenter(ball, -ball.radius - 16, -ball.radius -16);\n\n  //Add some text \n  message = g.text(\n    \"No collision...\", \n    \"16px sans-serif\",\n    \"black\", 10, 10\n  );\n    \n  //Change the state to `play`\n  g.state = play;  \n}\n\n//The `play` function will run in a loop\nfunction play() {\n\n  //Set the default message content \n  message.content = \"No collision...\";\n\n  /*\n  Check for a collision between the pointer and the \n  ball and box. The collision variables will be `true`\n  if there's a collision and `false` if there isn't.\n  Use the universal `hit` method to do the collision check.\n  `hit` arguments (only the first two are required):\n  spriteA, spriteB, reactToCollision?, bounce?, useGlobalCoordinates?\n  actionWhenCollisionOccurs\n  */\n\n  let boxCollision = g.hit(g.pointer, box),\n      ballCollision = g.hit(g.pointer, ball);\n\n  //You can alternatively use the lower-level `hitTestPoint` method\n  //`hitTestPoint` arguments:\n  //pointObject, sprite\n\n  /*\n  let boxCollision = g.hitTestPoint(g.pointer.position, box),\n      ballCollision = g.hitTestPoint(g.pointer.position, ball);\n\n  */\n\n  //Change the message if there's a collision with the box\n  if(boxCollision) {\n    message.content = \"Box!\"; \n  }\n\n  //Change the message if there's a collision with the ball\n  if(ballCollision) {\n    message.content = \"Ball!\"; \n  }\n}\n\n"]}