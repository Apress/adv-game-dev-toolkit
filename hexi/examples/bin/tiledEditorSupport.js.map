{"version":3,"sources":["../src/tiledEditorSupport.js"],"names":[],"mappings":"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","file":"tiledEditorSupport.js","sourcesContent":["/*\nLearn how to import and use data from Tiled Editor.\n\nHexi supports game maps and levels created using the popular Tiled\nEditor level designer:\n\nwww.mapeditor.org\n   \nTo prepare your Tiled Editor game world for use in Hexi, give any significant thing a\n`name` property. Anything with a `name` property in Tiled Editor can \nbe accessed in your code by its string name, as you'll see ahead. Tiled Editor layers have a \n`name` property by default, and you can assign custom `name`\nproperties to tiles and objects.\n\nOpen `maps/timeBomPanic.tmx` file in Tiled Editor and take a careful\nlook at how it's been structured. Notice how sprites have been\norganized into layers, and how those layers have been named and\nstacked. Also, notice that the tileset images of the alien and bomb \nboth have custom `name` properties: \"alien\" and \"bomb\".\n*/\n\nlet thingsToLoad = [\n  \"images/timeBombPanic.png\",\n  \"images/cat.png\",\n  \"maps/timeBombPanic.json\"\n];\n\n//Create a new Hexi instance, and start it.\nlet g = hexi(512, 512, setup, thingsToLoad);\n\n//Set the background color and scale the canvas\n//g.backgroundColor = \"black\";\ng.scaleToWindow();\n\n//Start Hexi\ng.start();\n\n//Game variables\nlet world, alien, message, wallMapArray,\n  bombMapArray, bombSprites, bombLayer,\n  leftArrow, upArrow, downArrow, rightArrow;\n\n//The `setup` function to initialize your application\nfunction setup() {\n\n  //Make the world from the Tiled JSON data and the tileset PNG image\n  world = g.makeTiledWorld(\n    \"maps/timeBombPanic.json\",\n    \"images/timeBombPanic.png\"\n  );\n\n  /*\n  Get a reference to the `alien` sprite.\n  Use `world.getObject` to do this. `getObject` searches for and\n  returns a sprite in the `world` that has a `name` property that\n  matches the string in the argument.\n  */\n  alien = world.getObject(\"alien\");\n\n  /*\n  Each Tiled Editor layer has a `name` that can be accessed in your\n  game code using\n  `world.getObject` Tiled Editor's `tilelayers` have a `data` property\n  that is an array containing all the grid index numbers (`gid`) of\n  the tiles in that array. In this example we want to access all the\n  wall sprites. In Tiled Editor, all the wall sprites were added to \n  a tile layer called `wallLayer`. We can access the `wallLayer`'s\n  `data` array of sprites like this: \n  */\n\n  wallMapArray = world.getObject(\"wallLayer\").data;\n\n  /*\n  We also need a reference to the bomb layer. All Tiled Editor layers are \n  created as `groups` by Hexi's `makeTiledWorld` method. That means they\n  all have a `children` array that lets' you access all the sprites on\n  that layer, if you even need to do that. \n  */\n\n  bombLayer = world.getObject(\"bombLayer\");\n\n  //Get a reference to the level's bomb layer array. This is the\n  //bomb layer's `data` array\n\n  bombMapArray = bombLayer.data;\n\n  /*\n  You can use `world.getObjects` (with an \"s\") to get an array of all\n  the things in the world that have the same `name` properties. There\n  are 5 bombs in the world, all which have share the same `name`\n  property: \"bomb\". Here's how you can access to all of them in an\n  array:\n  */\n\n  bombSprites = world.getObjects(\"bomb\");\n\n  //`bombSprites` is now an array that contains all the bomb sprites\n  //in the world\n\n  //Give the `alien` a `direction` property\n  alien.direction = \"\";\n\n  //Configure Hexi's built in arrow keys to assign the alien a direction\n  //Create some keyboard objects\n  leftArrow = g.keyboard(37);\n  upArrow = g.keyboard(38);\n  rightArrow = g.keyboard(39);\n  downArrow = g.keyboard(40);\n\n  //Program the keyboard objects\n  leftArrow.press = () => alien.direction = \"left\";\n  upArrow.press = () => alien.direction = \"up\";\n  rightArrow.press = () => alien.direction = \"right\";\n  downArrow.press = () => alien.direction = \"down\";\n\n  //Change the game state to `play`\n  g.state = play;\n}\n\n//The `play` function contains all the game logic and runs in a loop\nfunction play() {\n\n  //Change the alien's direction only if it's at an intersection\n  //(This keeps it aligned to the grid cells. You don't have to do\n  //this but it's a nice effect that you might want to use in your\n  //own games at some point.)\n\n  if (Math.floor(alien.x) % world.tilewidth === 0 && Math.floor(alien.y) % world.tileheight === 0) {\n    switch (alien.direction) {\n      case \"up\":\n        alien.vy = -4;\n        alien.vx = 0;\n        break;\n      case \"down\":\n        alien.vy = 4;\n        alien.vx = 0;\n        break;\n      case \"left\":\n        alien.vx = -4;\n        alien.vy = 0;\n        break;\n      case \"right\":\n        alien.vx = 4;\n        alien.vy = 0;\n        break;\n      case \"none\":\n        alien.vx = 0;\n        alien.vy = 0;\n        break;\n    }\n  }\n\n  //Move the alien\n  g.move(alien);\n\n  //Keep the alien contained inside the canvas\n  g.contain(alien, g.stage);\n\n  /*\n  Prevent the alien from walking through walls using the \n  versatile `hitTestTile` method. `hitTestTile` checks for a\n  collision between a sprite and a tile in any map array that you\n  specify. It returns a `collision` object. \n  `collision.hit` is a Boolean that tells you if a sprite is colliding\n  with the tile that you're checking. `collision.index` tells you the\n  map array's index number of the colliding sprite. You can check for\n  a collision with the tile against \"every\" corner point on the\n  sprite, \"some\" corner points, or the sprite's \"center\" point. (Each\n  of these three options has a different and useful effect, so experiment with\n  them.)\n\n  `hitTestTile` arguments:\n  sprite, array, collisionTileGridIdNumber, worldObject, spritesPointsToCheck \n\n  The `world` object (the 4th argument) has to have these properties:\n  `tileheight`, `tilewidth`, `widthInTiles`.\n\n  `hitTestTile` will work for any map array, not just those made with\n  Tiled Editor. So you can use it with your own game maps in the same way.\n\n  */\n\n  let alienVsFloor = g.hitTestTile(alien, wallMapArray, 0, world, \"every\");\n\n  //If every corner point on the alien isn't touching a floor tile (array gridIDNumber: 0) then\n  //prevent the alien from moving\n  //\n  if (!alienVsFloor.hit) {\n\n    //To prevent the alien from moving, subtract its velocity from its position\n    alien.x -= alien.vx;\n    alien.y -= alien.vy;\n    alien.vx = 0;\n    alien.vy = 0;\n  }\n\n  //Let the alien pick up bombs\n  let alienVsBomb = g.hitTestTile(alien, bombMapArray, 5, world, \"every\");\n\n  //Find out if the alien's position in the bomb array matches a bomb gid number\n  if (alienVsBomb.hit) {\n\n    //If it does, filter through the bomb sprites and find the one\n    //that matches the alien's position\n    bombSprites = bombSprites.filter(function(bomb) {\n\n      //Does the bomb sprite have the same index number as the alien?\n      if (bomb.index === alienVsBomb.index) {\n\n        //If it does, remove the bomb from the \n        //`bombMapArray` by setting its gid to `0`\n        bombMapArray[bomb.index] = 0;\n\n        //Remove the bomb sprite from its container group\n        g.remove(bomb);\n\n        //Alternatively, remove the bomb with `removeChild` on\n        //the `bombLayer` group\n        //bombLayer.removeChild(bomb);\n        //Filter the bomb out of the `bombSprites` array\n        return false;\n      } else {\n\n        //Keep the bomb in the `bombSprites` array if it doesn't match\n        return true;\n      }\n    });\n  }\n}"]}