{"version":3,"sources":["../src/breakout.js"],"names":[],"mappings":"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","file":"breakout.js","sourcesContent":["/*\nLearn how to use Hexi to build a\nbreakout game prototype\n*/\n\nlet thingsToLoad = [\n  \"images/bloxyee/bloxyee.json\",\n  \"fonts/puzzler.otf\",\n  \"sounds/music.wav\",\n  \"sounds/bounce.wav\"\n];\n\n//Create a new Hexi instance, and start it.\nlet g = hexi(512, 512, setup, thingsToLoad, load);\n\n//Set the background color and scale the canvas\n//g.backgroundColor = \"black\";\ng.scaleToWindow();\n\n//Start Hexi\ng.start();\n\n//Game variables\nlet paddle, ball, topBorder, blocks, blockFrames,\n    music, bounceSound, message, titleMessage,\n\n    //The size of the grid of blocks\n    gridWidth = 8,\n    gridHeight = 5,\n    cellWidth = 64,\n    cellHeight = 64,\n\n    //title sprites\n    title, playButton,\n\n    //Groups\n    titleScene, gameScene,\n\n    //Score\n    score = 0,\n\n    //The paddle wobble tween\n    paddleWobble;\n \n\n//The `load` function will run while assets are loading. This is the\n//same `load` function you assigned as Hexi's 4th initialization argument. \n//Its optional. You can leave it out if you don't have any files to\n//load, or you don't need to monitor their loading progress\n\nfunction load(){\n\n  //Display the file currently being loaded\n  console.log(`loading: ${g.loadingFile}`); \n\n  //Display the percentage of files currently loaded\n  console.log(`progress: ${g.loadingProgress}`);\n\n  //Add an optional loading bar \n  g.loadingBar();\n\n  //This built-in loading bar is fine for prototyping, but I\n  //encourage to to create your own custom loading bar using Hexi's\n  //`loadingFile` and `loadingProgress` values. See the `loadingBar`\n  //and `makeProgressBar` methods in Hexi's `core.js` file for ideas\n}\n\n//The `setup` function to initialize your application\nfunction setup() {\n\n  //Sound and music\n  bounceSound = g.sound(\"sounds/bounce.wav\");\n  music = g.sound(\"sounds/music.wav\");\n  music.loop = true;\n\n  //Create the sprites\n  //1. The `titleScene` sprites\n\n  //The `title`\n  title = g.sprite(\"title.png\");\n\n  //The play button\n  playButton = g.button([\n    \"up.png\",\n    \"over.png\",\n    \"down.png\"\n  ]);\n\n  //Set the `playButton`'s x property to 514 so that\n  //it's offscreen when the sprite is created\n  playButton.x = 514;\n  playButton.y = 350; \n\n  //Set the `titleMessage` x position to -200 so that it's offscreen\n  titleMessage = g.text(\"start game\", \"20px puzzler\", \"white\", -200, 300); \n\n  //Make the `playButton` and `titleMessage` slide in from the  \n  //edges of the screen using the `slide` function\n  g.slide(playButton, 250, 350, 30, \"decelerationCubed\");\n  g.slide(titleMessage, 250, 300, 30, \"decelerationCubed\");\n\n  //Create the `titleScene` group\n  titleScene = g.group(title, playButton, titleMessage);\n  \n  //2. The `gameScene` sprites\n  \n  //The paddle\n  paddle = g.sprite(\"paddle.png\");\n  g.stage.putBottom(paddle, 0, -24);\n  \n  //The ball\n  ball = g.sprite(\"ball.png\");\n  g.stage.putBottom(ball, 0, -128);\n\n  //Set the ball's initial velocity\n  ball.vx = 12;\n  ball.vy = 8;\n\n  //Add a black border along the top of the screen\n  topBorder = g.rectangle(512, 32, \"black\");\n\n  //Plot the blocks\n  //First create an array that stores references to all the\n  //blocks frames in the texture atlas\n  blockFrames = [\n    \"blue.png\", \n    \"green.png\", \n    \"orange.png\", \n    \"red.png\",\n    \"violet.png\"\n  ];\n\n  //Use the `grid` function to randomly plot the\n  //blocks in a grid pattern\n  blocks = g.grid(\n    gridWidth, gridHeight, 64, 64,\n    false, 0, 0,\n    () => {\n\n      //Choose a random block from the tileset for each grid cell\n      let randomBlock = g.randomInt(0, 4);\n      return g.sprite(blockFrames[randomBlock]);\n    }\n  );\n\n  //Position the blocks 32 pixels below the top of the canvas\n  blocks.y = 32;\n\n  //A text sprite for the score\n  message = g.text(\"test\", \"20px puzzler\", \"white\");\n  message.x = 8;\n  message.y = 8;\n\n  //Add the game sprites to the `gameScene` group\n  gameScene = g.group(paddle, ball, topBorder, blocks, message);\n\n  //Position the `gameScene` offscreen at -514 so that its\n  //not visible when the game starts\n  gameScene.x = -514;\n\n  //Program the play button's `press` function to start the game.\n  //Start the music, set the `state` to `play`\n  //make `titleScene` slide out to the right and\n  //the `gameScene` slide in from the left\n  playButton.press = () => {\n    if (!music.playing) music.play();\n    g.state = play;\n    g.slide(titleScene, 514, 0, 30, \"decelerationCubed\");\n    g.slide(gameScene, 0, 0, 30, \"decelerationCubed\");\n  };\n}\n\n//The `play` function contains all the game logic and runs in a loop\nfunction play() {\n\n  //Move the paddle to the mouse's position\n  paddle.x = g.pointer.x - paddle.halfWidth;\n\n  //Keep the paddle within the screen boundaries\n  g.contain(paddle, g.stage);\n  \n  //Move the ball\n  g.move(ball); \n\n  //Bounce the ball off the screen edges. Use the `contain` method\n  //with a custom `bounds` object (the second argument) that defines\n  //the area that the ball should bounce around in.\n  //Play the bounceSound when the ball hits one of these edges, \n  //and reduce the score by one if it hits the ground\n  let ballHitsWall = g.contain(\n    ball, \n    {x: 0, y: 32, width: g.canvas.width, height: g.canvas.height}, \n    true, \n\n    //what should happen when the ball hits the edges of the boundary?\n    (collision) => {\n\n      //Play the bounce sound\n      bounceSound.play();\n\n      //If the ball hits the bottom, perform these additional tasks:\n      if (collision.has(\"bottom\")) {\n\n        //Subract 1 from the score\n        score -= 1;\n\n        //Add optional screen shake\n\n        //Shake the screen (the `gameScene` sprite)\n        //`shake` arguments: sprite, magnitude, angularShake?\n        //g.shake(gameScene, 0.05, true);\n\n        //If `angularShake?` (the 3rd argument) is `true`, the sprite will shake around\n        //its axis. (Make sure that you've set your sprite's x/y pivot\n        //point to 0.5 for this to work effectively) The `magnitude` will be the maximum value, in\n        //radians, that it should shake. If `angularShake?` is `false`\n        //the shake effect will happen on the x/y axis. \n\n        //g.shake(gameScene, 16, false);\n        \n        //In that case\n        //the magnitude will be the maximum amount of displacement,\n        //in pixels.\n      }\n    }\n  );\n\n  /*\n  Check for a collision between the ball and the paddle, and \n  bounce the ball off the paddle. Play the `bounceSound` when \n  the collision occurs. \n  You can use the universal `hit` collision function to do this.\n  `hit` arguments:\n  spriteA, spriteB, reactToCollision?, bounce?, useGlobalCoordinates?\n  actionWhenCollisionOccurs\n  */            \n\n  let ballHitsPaddle = g.hit(\n    ball, paddle, true, true, true,\n    (collision) => {\n\n      //1. Play the bounce sound\n      bounceSound.play();\n\n      //2. Make the paddle wobble when the ball hits it.\n\n      //a. Remove any possible previous instances of the\n      //`paddleWobble` tween, and reset the paddle's scale\n      if (paddleWobble) {\n        paddle.scaleX = 1;\n        paddle.scaleY = 1;\n        g.removeTween(paddleWobble);\n      };\n\n      //b. Create the wobble tween\n      paddleWobble = g.wobble(\n        paddle, 1.3, 1.2, 5, 10, 10, -10, -10, 0.96\n      );\n    }\n  );\n  \n\n  /*\n  Check for a collision between the ball and the all \n  the blocks in the grid.\n  You can use the universal `hit` collision function to do this. If one\n  of the first two arguments is an array, the `hit` function will loop\n  through all the sprites in that array and check it for a collision\n  with the other sprite.\n  `hit` arguments:\n  spriteA, spriteB, reactToCollision?, bounce?, useGlobalCoordinates?\n  actionWhenCollisionOccurs\n  */\n\n  let ballHitsBlock = g.hit(\n    ball, blocks.children, true, true, true,\n    (collision, block) => {\n\n      //Add 1 to the score, play the bounce sound\n      //and remove the block that was hit\n      score += 1;\n      bounceSound.play();\n      g.remove(block);\n\n      //Create the particle effect\n      \n      //1. Find the globalCenterX and globalCenterY\n      //position for the block that was hit\n      let globalCenterX = block.gx + block.halfWidth,\n          globalCenterY = block.gy + block.halfHeight;\n\n      //2. Create the effect\n      g.createParticles(\n        globalCenterX, globalCenterY,            //x and y position\n        () => g.sprite(\"star.png\"),              //Particle function\n        g.stage,                                 //The container to add it to\n        20,                                      //Number of particles\n        0.3,                                     //Gravity\n        true,                                    //Random spacing\n        0, 6.28,                                 //Min/max angle\n        12, 24,                                  //Min/max size\n        5, 10,                                   //Min/max speed\n        0.005, 0.01,                             //Min/max scale speed\n        0.005, 0.01,                             //Min/max alpha speed\n        0.05, 0.1                                //Min/max rotation speed\n      );\n    }\n  );\n\n  //Display the current score\n  message.content = `Score: ${score}`;\n\n  //Check for the end of the game\n  if (blocks.empty) {\n\n    //Pause the game, wait for 1 second, and then\n    //call the `end` function\n    g.pause();\n    g.wait(1000, () => {\n       end(); \n    });\n  }\n}\n\n//A function that will run when the game ends\nfunction end() {\n\n  //Display the `titleScene` and hide the `gameScene`\n  g.slide(titleScene, 0, 0, 30, \"decelerationCubed\");\n  g.slide(gameScene, -514, 0, 30, \"decelerationCubed\");\n\n  //Display the final score\n  titleMessage.content = `Score: ${score}`; \n\n  //Lower the music volume\n  music.volume = 0.3;\n\n  //Assign a new button `press` action to\n  //`restart` the game\n  playButton.press = () => {\n    restart();\n  };\n}\n\n//A function to restart the game\nfunction restart() {\n\n  //Remove any remaining blocks if there are any\n  g.remove(blocks);\n\n  //Plot a new grid of blocks\n  blocks = g.grid(\n    gridWidth, gridHeight, 64, 64,\n    false, 0, 0,\n    () => {\n\n      //Choose a random block from the \n      //`blockFrames` array for each grid cell\n      let randomBlock = g.randomInt(0, 4);\n      return g.sprite(blockFrames[randomBlock]);\n    }\n  );\n\n  //Add the blocks to the `gameScene` and position it\n  gameScene.addChild(blocks);\n  blocks.y = 32;\n  blocks.x = 0;\n\n  //Reset the ball and paddle positions\n  g.stage.putBottom(paddle, 0, -22);\n  g.stage.putBottom(ball, 0, -128);\n\n  //Reset the ball's velocity\n  ball.vx = 12;\n  ball.vy = 8;\n\n  //Reset the score\n  score = 0;\n\n  //Set the music volume to full\n  music.volume = 1;\n  \n  //Hide the titleScene and reveal the gameScene\n  g.slide(titleScene, 514, 0, 30, \"decelerationCubed\");\n  g.slide(gameScene, 0, 0, 30, \"decelerationCubed\");\n  \n  //Set the game state to `play` and `resume` the game\n  g.state = play;\n  g.resume();\n}\n\n"]}