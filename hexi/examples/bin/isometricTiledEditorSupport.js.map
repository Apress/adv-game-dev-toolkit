{"version":3,"sources":["../src/isometricTiledEditorSupport.js"],"names":[],"mappings":"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","file":"isometricTiledEditorSupport.js","sourcesContent":["/*\n\nAn example of how to use `makeIsoTiledWorld` to create\nan isometric game world using Tiled Editor JSON map data. \nIt uses the same API as its Cartesian equivalent `makeTiledWorld` method. \nHowever, you need to make sure you set Tile Editor up correctly and add s\nome custom map properties to make it work. Let's find out how.\n\n###Configuring and building the map\nBefore you start creating your Tiled Editor map, prepare a sprite \nsheet with the isometric tiles that you want to use. And, \nvery importantly, note down the isometric dimensions of sprites. \nHere are the pixel dimensions you need to know:\n\n•   `tilewidth`: The width of the sprite, from its left to right edge.\n•   `tileheight`: The height of the tileheighte’s base area. This is just the height of the squashed diamond shape which defines the base on which the isometric sprite is standing. Usually its half the `tilewidth` value.\n\nThese properties are the property names that are used by Tiled Editor, \nand you’ll be able to access them in the JSON data file \nthat Tiled Editor generates.\n\nYou can now use the values to create a new isometric map in Tiled Editor. \nOpen Tiled Editor and select File ~TRA New from the main menu. \nIn the New Map dialog box, select isometric as the Orientation, \nand use the tilewidth and tileheight values I described above \nfor the Width and Height. \n\nBut we’re not done yet! There are three more values we need to figure out:\n\n•   tileDepth: The total height of the isometric sprite, in pixels. \n•   cartWidth: The Cartesian width of each tile grid cell, in pixels.\n•   cartHeight: The Cartesian height of each tile grid cell, in pixels.\n\nYou need to add these values as custom properties in Tiled Editor’s \nMap Properties panel.\n\nWhen Tiled Editor generates the JSON map data, you'll be able to access these values in the `properties` field.\n```\n\"properties\":\n    {\n     \"cartTileheight\":\"32\",\n     \"cartTilewidth\":\"32\",\n     \"tileDepth\":\"64\"\n    },\n```\nNow that you’ve got the Map Properties all set up, use your \nisometric tileset to build your world. \nWhen you're finished designing your map, export it as a JSON file, \nand you’re now ready to use it to start coding a game. Here's how to use \n`makeIsoTiledWorld` from the JSON map data and isometric `cubes.png` tileset. \n```\nworld = tu.makeIsoTiledWorld(\n  \"images/cubes.json\",\n  \"images/cubes.png\"\n);\n```\n*/\n\n\n//The files we want to load\nlet thingsToLoad = [\n  \"images/cubes.png\",\n  \"images/cubes.json\"\n];\n\n//Create a new Hexi instance, and start it.\nlet g = hexi(512, 512, setup, thingsToLoad);\n\n//Scale the canvas to the maximum browser dimensions\ng.scaleToWindow();\n\n//Declare variables used in more than one function\nlet world, leftArrow, upArrow,\n  rightArrow, downArrow, message, wallLayer,\n  player, wallMapArray;\n\n//Start Hexi\ng.start();\n\nfunction setup() {\n\n  //Make the world from the Tiled JSON data\n  world = g.makeIsoTiledWorld(\n    \"images/cubes.json\",\n    \"images/cubes.png\"\n  );\n\n  //Add the world to the `stage`\n  g.stage.addChild(world);\n\n  //Position the world inside the canvas\n  let canvasOffset = (g.canvas.width / 2) - world.tilewidth / 2;\n  world.x += canvasOffset;\n  world.y = 0;\n\n  //Get the objects we need from the world\n  player = world.getObject(\"player\");\n  wallLayer = world.getObject(\"wallLayer\");\n\n  //Add the player to the wall layer and set it at\n  //the same depth level as the walls\n  wallLayer.addChild(player);\n  player.z = 0;\n  wallLayer.children.sort(g.byDepth);\n\n  //Initialize the player's velocity to zero\n  player.vx = 0;\n  player.vy = 0;\n\n  //Make a text object\n  message = g.text(\"\", \"16px Futura\", \"black\");\n  message.setPosition(5, 0);\n\n  //Create the keyboard objects\n  leftArrow = g.keyboard(37);\n  upArrow = g.keyboard(38);\n  rightArrow = g.keyboard(39);\n  downArrow = g.keyboard(40);\n\n  //Assign the key `press` actions\n  player.direction = \"none\";\n  leftArrow.press = () => player.direction = \"left\";\n  upArrow.press = () => player.direction = \"up\";\n  rightArrow.press = () => player.direction = \"right\";\n  downArrow.press = () => player.direction = \"down\";\n  leftArrow.release = () => player.direction = \"none\";\n  upArrow.release = () => player.direction = \"none\";\n  rightArrow.release = () => player.direction = \"none\";\n  downArrow.release = () => player.direction = \"none\";\n\n  //Set the game state to `play`\n  g.state = play;\n}\n\nfunction play() {\n\n  //Change the player character's velocity if it's centered over a grid cell\n  if (Math.floor(player.cartX) % world.cartTilewidth === 0 && Math.floor(player.cartY) % world.cartTileheight === 0) {\n    switch (player.direction) {\n      case \"up\":\n        player.vy = -2;\n        player.vx = 0;\n        break;\n      case \"down\":\n        player.vy = 2;\n        player.vx = 0;\n        break;\n      case \"left\":\n        player.vx = -2;\n        player.vy = 0;\n        break;\n      case \"right\":\n        player.vx = 2;\n        player.vy = 0;\n        break;\n      case \"none\":\n        player.vx = 0;\n        player.vy = 0;\n        break;\n    }\n  }\n\n  //Update the player's Cartesian position \n  //based on its velocity\n  player.cartY += player.vy;\n  player.cartX += player.vx;\n\n  //Wall collision\n  //Get a reference to the wall map array\n  wallMapArray = wallLayer.data;\n\n  //Use `hitTestIsoTile` to check for a collision\n  let playerVsGround = g.hitTestIsoTile(player, wallMapArray, 0, world, \"every\");\n\n  //If there's a collision, prevent the player from moving.\n  //Subtract its velocity from its position and then set its velocity to zero\n  if (!playerVsGround.hit) {\n    player.cartX -= player.vx;\n    player.cartY -= player.vy;\n    player.vx = 0;\n    player.vy = 0;\n  }\n\n  //Add world boundaries\n  let top = 0,\n    bottom = (world.heightInTiles * world.cartTileheight),\n    left = 0,\n    right = (world.widthInTiles * world.cartTilewidth);\n\n  //Prevent the player from crossing any of the world boundaries\n  //Top\n  if (player.cartY < 0) {\n    player.cartY = top;\n  }\n\n  //Bottom\n  if (player.cartY + player.cartHeight > bottom) {\n    player.cartY = bottom - player.cartHeight;\n  }\n\n  //Left\n  if (player.cartX < left) {\n    player.cartX = left;\n  }\n\n  //Right\n  if (player.cartX + player.cartWidth > right) {\n    player.cartX = right - player.cartWidth;\n  }\n\n  //Position the sprite's screen `x` and `y` position\n  //using its isometric coordinates\n  player.x = player.isoX;\n  player.y = player.isoY;\n\n  //Get the player's index position in the map array\n  player.index = g.getIndex(\n    player.cartX, player.cartY,\n    world.cartTilewidth, world.cartTileheight, world.widthInTiles\n  );\n\n  //Depth sort the sprites if the player is moving\n  if (player.vx !== 0 || player.vy !== 0) {\n    wallLayer.children.sort(g.byDepth);\n  }\n\n  //Display the player's x, y and index values\n  message.content = `index: ${player.index}`;\n}"]}